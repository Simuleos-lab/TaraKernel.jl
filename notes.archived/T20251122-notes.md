# record interface

- **load!**
    - Overwrite the in-RAM LiteRecord with the on-disk version.
    - Must load a valid TaraSON payload.
    - No complex metadata logic is performed here.

- **write**
    - Overwrite the on-disk version with the in-RAM LiteRecord.
    - Writing always produces a valid *lite* JSON/TaraSON object.

- **load_ondemand!**
    - Like `load!` but only loads from disk if RAM data is empty.

- **commit**
    - Turn a DynamicLiteRecord into a StaticLiteRecord.
    - The committed representation becomes immutable.
    - Hashing is delegated to the Tape layer (TaraKernel); LiteRecords do *not* embed hash metadata inside the record.

- **getindex**
    - Query a LiteRecord’s content (strings, numbers, small arrays, shallow dicts).

- **setindex!**
    - Update a LiteRecord’s content.
    - Must maintain lite discipline (values must remain TaraSON-compatible).

- Chain-missing or alternative indexing behavior is not part of LiteRecords anymore.
- Vector interface support should remain minimal and consistent with Dict-like semantics.
- Locking and querying live one level above LiteRecords (Recorder layer), not inside LiteRecords.

---

# NOTE
- Recommended pattern:
    - centralize low-level operations through `_getindex(...) -> (store, key)`
    - keeps implementation clear and avoids coupling to higher-level query systems.

---

# CONTENT & HASHING MODEL (updated)

- LiteRecords no longer embed content-hash metadata internally.
- Hashing is handled by the **Tape** layer (TaraKernel) when a record becomes a segment payload.
- LiteRecords remain *pure lite data structures*: no self-referential hashing, no commit history.

- Structure must remain:
    ```json
    {
        "key": "value",
        "a": 123,
        "b": ["x","y"],
        "c": {"sub": 1}
    }
    ```

- No reserved keys such as `__literecord_meta__` or `__nodemeta__` are used inside user LiteRecords.
- Any bookkeeping (segment position, content hash, timestamps) lives outside LiteRecords, in the Tape segment metadata.

---

# DESIGN

- Two operating modes exist **outside** LiteRecords:
    - **Static records**  
        Provided by the Tape system. Immutable. Loaded from segments.
    - **Dynamic records**  
        In-memory, mutable LiteRecords that will become segment payloads upon commit.

- LiteRecords themselves remain:
    - lightweight,
    - JSON/TaraSON compatible,
    - deterministic,
    - schema-free except for lite-discipline rules.

- LiteRecords do *not* implement per-record commit history, diffing, or hashing.
- All content-addressing and immutability semantics are owned by the Tape layer.

---

# NOTE

- `ContextRecord{KT,VT,DT}` mentioned in earlier designs is now folded into a single notion:
    - **LiteRecord = the base lite structure**
    - **ContextRecord = a LiteRecord used as a semantic description at Recorder level**
- LiteRecords stay general; ContextRecord is a *usage pattern*, not a different type.

---

# NOTE — Lite discipline

- LiteRecords must contain only:
    - strings  
    - numbers  
    - booleans  
    - `nothing`  
    - small vectors  
    - shallow dictionaries  
- No Julia objects, no nested heavy structures.
- Enforcing lite discipline occurs at Recorder level; LiteRecords simply require inputs to be TaraSON-compatible.

---

# NOTE — Querying

- Extended querying (regex paths, multi-key navigation, etc.) is removed from LiteRecords.
- Higher-level recorders (e.g., Simuleos) may implement advanced querying on top of LiteRecords.
- LiteRecord core remains intentionally minimal: Dict-like operations only.

