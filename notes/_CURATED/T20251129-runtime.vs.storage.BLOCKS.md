***
## Runtime / Storage: Kernel Boundaries

#MODEL

The kernel operates across exactly two layers:

- **Runtime**
  - In-memory representations under kernel control.
  - Mutable, transitional, and non-authoritative.
  - Used for construction, manipulation, and validation prior to commitment.

- **Storage**
  - Byte sequences previously emitted by the kernel.
  - Considered authoritative **because they were committed by the kernel**,
    not because they are trusted by assumption.
  - Subject to continuous kernel validation when read.

- The **Storage Backend** itself is not authoritative.
It is a logistical substrate used by the kernel to persist and retrieve bytes.
- Authority belongs to kernel-validated bytes,
not to the backend that stores them.

***

## Runtime Layer

- #MODEL
- Runtime representations exist solely for:
  - construction,
  - manipulation,
  - validation,
  - staging prior to commit.
- Runtime objects are not identity-bearing by default.
- Runtime objects may temporarily violate canonical form.
- Runtime objects acquire authority only when committed by the kernel.

***

## Storage Layer

#MODEL
- Storage consists of byte sequences previously written by the kernel.
- These bytes are treated as authoritative *if and only if* they validate under kernel rules when read back.
- Corruption may occur in Storage.
- Storage authority is therefore conditional and continuously verified.
- Storage is not trusted because it is correct.
- Storage is authoritative because the kernel put the bytes there and verifies them whenever they are used.

***

## Canonical Representation (Kernel Invariant)

- #LAW
- Canonical representation is a kernel invariant applied to storage-grade data.
- Canonical representation is:
  - flat TaraSON,
  - deterministic,
  - byte-stable,
  - hashable.
- Canonical representation is:
  - produced by the kernel,
  - validated by the kernel,
  - required for identity and hashing.
- Canonical representation is not:
  - a backend concern,
  - a storage format,
  - a runtime structure.
- The backend does not know what “canonical” means.

***

## Abstraction Boundary: Projection vs Internal Representation

- #MODEL
- A Storage Backend distinguishes between:
    - its internal representation (backend-private),
    - a kernel-facing projection.

- Internally, a backend may store data in any form.
- Externally, a backend MUST project stored bytes through
the kernel-defined Tape interface.
- The kernel never observes backend-internal representation.
- It only observes the projection.

***

## Kernel Tape Model (Structural Invariant)

- #LAW
- The Tape model is a kernel invariant.
- It defines exactly the following ordered structures:
- A `TapeLibrary` is an ordered, append-only sequence of Tapes.
- A `Tape` is an ordered, append-only sequence of Segments.
- A Segment is an ordered, append-only sequence of Records.
- A Record is an atomic byte payload.

This structure defines ordering and containment only.
It introduces no semantic interpretation.

***

## Backend Obligation with the Kernel

- #LAW
- A Storage Backend has the following obligations:

### Consistency Obligation
- Store byte payloads provided by the kernel.
- Return those payloads bytewise identical upon request.
- Preserve record boundaries as provided by the kernel.
- Preserve ordering as instructed by the kernel.
- Enforce append-only behavior mechanically.

### Structural Obligation
- Expose stored bytes through the Lib / Tape / Segment / Record projection.
- Support deterministic iteration at each level of that projection.

### Non-Obligations
- The backend MUST NOT validate canonical representation.
- The backend MUST NOT compute or verify hashes.
- The backend MUST NOT interpret record content.
- The backend MUST NOT infer relationships beyond ordering and containment.
- The backend enforces logistics and order, not correctness or meaning.

***

## Input Boundary (Read Path)

#MODEL
Storage bytes
→ Tape projection
→ Kernel validation
→ Runtime objects
- Bytes are treated as opaque until validated by the kernel.
- Validation determines whether bytes are accepted as Storage-grade content.
- Runtime objects reconstructed from Storage are static and immutable.

***

## Output Boundary (Write Path)

#MODEL
Runtime objects
→ kernel canonicalization
→ kernel hashing
→ Storage append

- Canonicalization and hashing are kernel operations.
- The backend receives only opaque byte payloads.
- Authority begins at kernel commit, not at backend storage.

***

## Hashing Rule

- #LAW
- All content hashes are computed exclusively by the kernel
from canonical byte representations.
- Hashes are never derived from:
    - runtime structure,
    - backend representation,
    - physical storage layout.
- Identity is a kernel construct.

***

## Runtime Working Representation

#MODEL

- Runtime objects provide a DOM-like interface over kernel structures, the Tape interface.
- This interface is a projection of ordered containment.
- It is a convenience for traversal and manipulation.
- Runtime structure does not add meaning.
- It reflects kernel ordering invariants only.

***

## Backend Model Summary

#MODEL

A Storage Backend MUST:

- store opaque byte payloads,
- return them bytewise unchanged,
- preserve ordering and append semantics,
- project content through the Tape interface.

A Storage Backend MAY:

- use any internal data model,
- use any physical storage layout,
- use any indexing or buffering strategy.

Only the projection and bytewise consistency are kernel-visible.

***
