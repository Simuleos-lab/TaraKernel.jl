## TaraSON: Summary

- TaraSON is a **JSON-compatible file format** for encoding flat records:
    - each record is a finite collection of `"full.canonical.key" => primitive` pairs,
    - keys are **ordered deterministically** in the serialized form,
    - keys MUST be valid `JSON-Pointer`s.
- TaraSON admits **no arrays, no nested dictionaries, and no structured objects** at the format level.
- A record’s **canonical representation is TaraSON-compatible**:
    - under kernel authority, the **canonical bytes are serialized as TaraSON**,
    - these TaraSON bytes are what the kernel uses for hashing and identity,
    - canonical identity is defined by canonicalization rules, not by runtime structure,
    - all structure and composite meaning exist outside the canonical layer, in runtime representations.

***
## TaraSON: Canonical equality and hashing are trivial

Flattening all structure means:
- **one primitive = one fully contextualized fact**,  
- canonicalization = “collect all facts, derive stable paths, sort them, serialize.”  
There is no structural ambiguity and no need to standardize array/dict semantics across languages.

***
## TaraSON: Structure is recoverable on demand  

Consumers who want nested or array structures simply **rebuild them from key prefixes** and numeric segments. This shifts complexity out of the canonical layer into adapters, where it is easier to manage and evolve.

***
## TaraSON: Line-oriented and easy to parse  

A TaraSON record becomes a **line-by-line key–primitive listing**. Because structure is encoded only in the key string:
- custom parsers are trivial to write,
- streaming is natural,
- splitting, diffing, indexing, and filtering work directly on lines,
- the format behaves well with generic tools (`grep`, `awk`, `sort`, etc.).

***
## TaraSON: Compression captures nearly all redundancy

Repeated path prefixes compress extremely well under gzip/zstd/LZMA. A flat fact model produces many repeated substrings, which modern compressors reduce to small back-references. The storage penalty of flattening disappears in practice.

***
## TaraSON: Design consequences

- The canonical representation is strictly flat; structure is a runtime concern.
- A clear path grammar becomes essential (separators, numeric indices, reserved patterns).
- Any language can map its native structures to `TaraSON` via a small adapter layer.
- The kernel benefits from deterministic, uniform, and easily hashed canonical records.

***
