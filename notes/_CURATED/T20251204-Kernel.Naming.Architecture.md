## Kernel Naming Architecture (KNA): Purpose
* #MODEL
* Define a stable semantic architecture for TaraKernel naming.
* Separate kernel authority from user extension.
* Prevent semantic drift caused by syntax sugar or overriding.
* Make kernel invariants explicit and non-bypassable.
* Provide long-term auditability of behavior by name alone.

---

## KNA: Kernel vs `TaraKernel.Base`
* #MODEL
* The **kernel** is the total semantic system:
  * `TaraKernel.Base`
  * plus all loaded kernel extensions.
* `TaraKernel.Base` is:
  * the original kernel provider,
  * not the entire kernel.
* Kernel meaning may exist outside `TaraKernel.Base`.
* Kernel meaning is unified through `tk_*` and `_tk_*` methods.

---

## KNA: `tk_*` Prefix: Kernel Contract
* #LAW
* Any symbol prefixed with `tk_` defines **kernel-level semantic meaning**.
* `tk_*` names represent the **contract of behavior** for kernel objects.
* `tk_*` functions may be:
  * fully implemented by `TaraKernel.Base`,
  * partially implemented by `TaraKernel.Base`,
  * or intentionally undefined by `TaraKernel.Base`.
* Lack of an implementation is itself part of the contract:
  * users must supply one to participate in kernel semantics.
* Implementing `tk_*` is not customization.
* Implementing `tk_*` is **extending the kernel**.

---

## KNA: `tk_*` Functions Are
* #LAW
* They are not convenience wrappers.
* They are not ergonomic surfaces.
* They are semantic entry points into kernel logic.
* They define:
  * meaning
  * contracts
  * canonical interpretation
* Exposure exists for:
  * extension,
  * testing,
  * reasoning,
  * documentation.
* They must not be treated as sugar.

---

## KNA: `tk_*` Is Independent of Julia `Base`
* #DECISION
* Kernel semantics are decoupled from Julia’s standard library.
* `tk_*` names do not mirror Base.
* They define meaning, not syntax.
* Any mapping from Julia `Base` into kernel semantics is:
  * a layer above,
  * optional,
  * non-authoritative.
* Semantics do not originate from syntax.
* The kernel never depends on syntactic affordances for correctness.

---

## KNA: `_tk_*` Prefix: Kernel Reference Implementation
* #LAW
* Any symbol prefixed with `_tk_` denotes the **`TaraKernel.Base`-provided implementation**.
* `_tk_*` exists only when `TaraKernel.Base` can supply a canonical implementation.
* `_tk_*` represents:
  * `TaraKernel.Base` semantics
* User code must not override `_tk_*`.

---

## KNA: `_tk_*` Guards Kernel Reality
* #MODEL
* `_tk_*` forms an invariant membrane *within `TaraKernel.Base`*.
* It protects:
  * kernel truth as implemented by `TaraKernel.Base`,
  * consistency,
  * safety,
  * canonical meaning.
* Kernel-internal code may rely on `_tk_*` for invariant correctness.
* Users can call `_tk_*` if a `TaraKernel.Base` implementation is required.
    * bypassing any extension.

---

## KNA: `_tk_*` vs `tk_*`
* #MODEL
* `_tk_*` and `tk_*` express the same semantic contract.
* `_tk_*` represents:
  * kernel meaning as implemented by `TaraKernel.Base`.
* `tk_*` represents:
  * current kernel meaning (Base + extensions).
* Calling `_tk_*` means:
    * guaranteed invocation of `TaraKernel.Base` implementation.
* Calling `tk_*` means:
    * invocation of the current effective kernel meaning,
    * possibly extended by the user.
* `_tk_*` is never broader than `tk_*`.
* `tk_*` may extend behavior, not redefine meaning.

---

## KNA: `TaraKernel.Base` rules
* If `_tk_*` exists:
  * `tk_* = _tk_*` always.
* If `_tk_*` does not exist:
  * `tk_*` is a mandatory 
  * kernel extension is need it.
* `_tk_*` may be missing.
* `tk_*` always exists as a semantic interface.

---

## KNA: Reference vs Extension
* #INSIGHT
* `_tk_*` defines what `TaraKernel.Base` *implements*.
* `tk_*` defines what the kernel currently *means*.
* Several user might extend the same `tk_*` method
* Implementation may be absent.
* Meaning never is.
* General Julia extension hygine rules applies

---

## KNA: Abstract Types Require Kernel Extension
* #MODEL
* When a `_tk_*` implementation does not exist:
  * `TaraKernel.Base` defines meaning but not behavior.
* In such cases:
  * `tk_*` is intentionally abstract.
    * for instance
        * `TaraKernel.Base.tk_fun(x::AbstractType) = error("Missing Implementation")`
  * implementation is assigned to the user.
* This is not a defect.
* This is an extension hook.
* This is designed extensibility.

---

## KNA: User Interface Layer Is Deliberately Separate
* #LAW
* Public-facing names, if provided, are:
  * unprefixed,
  * ergonomic,
  * user-defined.
* Public API may:
  * call `tk_*` for kernel meaning,
  * override `tk_*`,
  * call `_tk_*` if `TaraKernel.Base` meaning is required,
  * wrap either for convenience,
  * or ignore kernel semantics entirely.
* No behavior is guaranteed at this layer.
* No authority exists here.

---

## KNA: Base Integration Is Non-Semantic
* #LAW
* Julia `Base` integration is:
  * surface-level,
  * optional,
  * syntactic only.
* Base methods never define behavior.
* They may forward.
* They may adapt.
* They never assert meaning.
* Kernel truth does not exist there.

---

## KNA: Extending `tk_*` Is Kernel Participation
* #MODEL
* Users who implement `tk_*`:
  * do not customize behavior,
  * do not add features,
  * do not adapt syntax.
* They participate in kernel semantics.
* They instantiate meaning.
* This is kernel participation, not configuration.

---

## KNA: Versioned Semantics
* #MODEL
* `_tk_*` is versioned with `TaraKernel.Base`.
* Kernel semantics evolve across versions.
* `tk_*` reflects:
  * current kernel meaning,
  * beyond `TaraKernel.Base`.
* Compatibility is semantic, not syntactic.

---

## KNA: Kernel Truth Exists Independently of API
* #LAW
* Kernel semantics must remain valid regardless of:
  * Julia Core.Base integration,
  * user overrides,
  * surface naming,
  * syntactic flavor.
* Meaning is owned by `tk_*` and `_tk_*`.
* Nothing else defines behavior.

---

## KNA: Separation Is Structural, Not Stylistic
* #LAW
* This naming scheme is not cosmetic.
* It encodes:
  * authority,
  * trust,
  * mutability,
  * semantic depth.
* Confusing layers is a system error.
* Not a convenience failure.

---

## KNA: Summary: Semantic Stratification
* #MODEL
* TaraKernel operates with four semantic strata:
  1. Syntax and surface API (user space)
  2. Kernel contract (`tk_*`)
  3. Kernel reference implementation (`_tk_*`)
  4. Internal utilities (auxiliary mechanics)
* Only layers (1–2) are extensible.
* Only layer (3–4) is internal to `TaraKernel.Base`.
* Layer 1 carries non-kernel semantics.
* Layer 2-3 defines kernel meaning.
* Layer 3 enforces `TaraKernel.Base` implementation.
* Layer 4 has no kernel semantics.
