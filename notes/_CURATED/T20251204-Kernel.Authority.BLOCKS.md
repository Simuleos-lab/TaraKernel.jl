## Kernel Authority
* #LAW
* Kernel authority defines the domain in which TaraKernel invariants are **binding**.
* Data is said to be **under kernel authority** when:
    * it is represented by a `TaraKernel.DataType`,
    * or it resides in `Storage` governed by a backend participating in kernel semantics,
    * or it is currently being processed by a `tk_*` function.
* While data is under kernel authority:
    * all declared kernel invariants apply,
    * violations are kernel errors,
    * `tk_*` functions are the only legal operations,
    * kernel semantics override external interpretation,
    * correctness is measured only against kernel contracts.
* Kernel authority **does not exist** outside these boundaries:
    * `External.DataType` values are not under kernel authority,
    * pre-ingestion runtime structures are outside kernel invariants,
    * exported data loses kernel authority immediately when leaving a DataFlow,
    * kernel guarantees do not extend beyond the `tk_*` boundary.
* Crossing into kernel authority occurs only via a `DataFlow`.
* Crossing out of kernel authority occurs only via a `DataFlow`.
* A DataFlow therefore defines:
    * where authority begins,
    * where it ends,
    * and what invariants become active at each boundary.
* Kernel authority is **structural, not synthetic**:
    * it does not depend on language,
    * it does not depend on storage technology,
    * it does not depend on runtime representation,
    * it depends only on participation in kernel semantics.
* Kernel authority defines **responsibility transfer**:
    * before authority: correctness belongs to the user,
    * under authority: correctness belongs to the kernel,
    * after authority: correctness returns to the environment.
* Kernel authority describes obligation, not execution:
    * it is not a runtime mode,
    * it is not a flag,
    * it is not an object,
    * it is a semantic state enforced by contract.

---

## Storage: Authority and Truth
- #LAW
- The kernel recognizes **Storage** as the authoritative source of truth.
- Storage is not “best effort” persistence.
- Storage is the definition of what has been recorded.
- It is a kernel violation for invalid data to exist at Storage.
    - No unvalidated record may be committed.
    - No unchecked structure may persist.
    - No unverifiable byte sequence may be treated as data.
- Storage content MUST be continuously valid under kernel invariants:
    - canonical encoding,
    - content hashing,
    - commit verification,
    - structural integrity.
- Validation is not a write-time convenience.
- Validation is a permanent obligation of the kernel.
- Any of the following conditions invalidate Storage:
    - detected corruption,
    - hash mismatches,
    - invalid commits,
    - illegal rewriting,
    - or violations of canonical form.
- Storage is authoritative not because it is correct by assumption,
  but because correctness is enforced.
- Storage does not represent a belief.
- It represents **fact**.
- Storage is not:
    - a cache,
    - a materialized view,
    - a denormalized projection,
    - or an optimization.
- Storage is the historical ground truth of the system.
- Runtime may speculate.
- Runtime may be wrong.
- Storage MUST NOT be.
- If Runtime contradicts Storage: Runtime is wrong.
- If Storage contradicts itself: the kernel is in error.
