# TaraSON as a Flat Fact Model

- `#UNDER/CONSIDERATION`

## Summary
TaraSON can be defined as a **pure flat fact format**: each record is just a finite set of  
`"full.canonical.key" => primitive`  
pairs. This canonical layer contains **no arrays, no nested dicts, no objects**. All higher-level structures belong to the *runtime representation* and are merely convenience abstractions provided by host languages.

## Rationale
### 1. Canonical layer remains minimal and universal  
At the kernel level, TaraSON only commits to:
- a path grammar for canonical keys,
- a small set of primitive values,
- deterministic ordering and serialization.

Everything else—lists, maps, objects—is an interpretation introduced by the runtime. This separation keeps TaraSON simple, cross-language consistent, and easy to reason about.

### 2. Canonical equality and hashing become trivial  
Flattening all structure means:
- **one primitive = one fully contextualized fact**,  
- canonicalization = “collect all facts, derive stable paths, sort them, serialize.”  
There is no structural ambiguity and no need to standardize array/dict semantics across languages.

### 3. Structure is recoverable on demand  
Consumers who want nested or array structures simply **rebuild them from key prefixes** and numeric segments. This shifts complexity out of the canonical layer into adapters, where it is easier to manage and evolve.

### 4. Line-oriented and easy to parse  
A TaraSON record becomes a **line-by-line key–primitive listing**. Because structure is encoded only in the key string:
- custom parsers are trivial to write,
- streaming is natural,
- splitting, diffing, indexing, and filtering work directly on lines,
- the format behaves well with generic tools (`grep`, `awk`, `sort`, etc.).

### 5. Compression captures nearly all redundancy  
Repeated path prefixes compress extremely well under gzip/zstd/LZMA. A flat fact model produces many repeated substrings, which modern compressors reduce to small back-references. The storage penalty of flattening disappears in practice.

## Consequences
- The canonical representation is strictly flat; structure is a runtime concern.
- A clear path grammar becomes essential (separators, numeric indices, reserved patterns).
- Any language can map its native structures to TaraSON via a small adapter layer.
- The kernel benefits from deterministic, uniform, and easily hashed canonical records.

## Decision Status
This model is coherent and attractive; it should remain under consideration until we commit to the final TaraSON path grammar and primitive set.
