***

## Tara Kernel: Scope

#MODEL

- The Tape kernel is the minimal component responsible for **authoritatively mediating
semantic transitions of records** between `Runtime` and `Storage`.
- In particular, the kernel defines and enforces the only legal transitions:
    - from **Storage-grade canonical data** into **Runtime records** (read path),
    - from **Runtime records** into **committed, identity-bearing data** (write path).
- These transitions are expressed abstractly as:
    - `StoreBackend.Tape` → `TaraKernel` → `Runtime.Record`
    - `Runtime.Record` → `TaraKernel` → `Committed.Record` → `StoreBackend.Tape`
- The kernel does **not** interpret meaning.
- It establishes 
    - **authority boundaries**
    - fixes **content identity** 
    - enforces **invariants**
- Whatever is **strictly necessary** to:
    - canonicalize records,
    - assign and verify content identity,
    - enforce immutability and append-only structure,
    - validate stored content,
- belongs in the kernel.
- Everything else 
    - interpretation
    - querying
    - schema
    - semantics
    - concurrency
    - persistence strategies
    - user ergonomics
- must exist, **outside** the kernel.

***

## Tara Kernel: Purpose

- #MODEL
- The kernel:
    - operates over **Tapes** and their segments as the sole authoritative substrate,
    - mediates boundary crossings between runtime representations and canonical records,
    - enforces canonicalization, hashing, commit structure, and validation,
    - defines and enforces a small, fixed set of non-negotiable invariants.
- Higher-level meaning (Issues, Scopes, Contexts, interpretation, intent) is explicitly
**excluded from kernel semantics** and must not influence kernel behavior.

***

## Tara Kernel: In-Kernel Objects (Tape)

#MODEL
A (committed) **Tape** is a **finite, ordered sequence of segments** managed under kernel authority.
- The physical storage substrate is abstract and delegated to backends.
- A Tape carries no intrinsic meaning and performs no interpretation.
- A Tape’s **identity** is determined solely by:
  - the ordered sequence of its committed segments,
  - the canonical records expanded from those segments,
  - and the validation of content identity through kernel-enforced hashing.
- All Tape identity is content-derived:
  - independent of runtime structure,
  - independent of backend layout,
  - and stable across environments.

***

## Tara Kernel: Out-of-Scope

- `#MODEL`
- The following concerns are explicitly **not** part of the Tape kernel.
- They lie outside kernel authority and are delegated to higher layers,
backends, or the execution environment.

- **Artifacts and Heavy Data**
- Heavy or non-lite data is always handled **outside** the kernel.
- Artifact references must appear as regular `TaraSON` fields.
- The kernel does not interpret, dereference, or validate artifacts.
- For the kernel, a link is **uninterpreted data**
    - it is indistinguisible from other data
    - carries no intrinsic semantics.

- **Concurrency and Transaction Models**
- Concurrency control, locking, and multi-process coordination
  belong to storage backends and the surrounding environment.
- The kernel assumes a **serialized, append-only byte stream** at its storage boundaries.
- The kernel does not define atomicity, isolation, or recovery protocols.
- Violations caused by concurrent misuse are outside kernel responsibility.

- **High-Level Querying**
- The kernel provides only **structural traversal**:
  ordered iteration over tapes, segments, and records.
- No filtering, indexing, aggregation, or semantic querying
  is defined at the kernel level.
- All higher-level query semantics are implemented outside the kernel.


***

## Tara Kernel: Canonicalization

#MODEL
Canonicalization is the kernel operation that fixes record identity by projecting
runtime data into its unique, authoritative representation.

- Input:
  - runtime records under kernel authority
    (e.g. DynamicLiteRecord or equivalent)
- Output:
  - a canonical flat TaraSON representation
    suitable for hashing, identity, and commitment

Rules:
- Canonicalization produces a deterministic, byte-stable representation.
- Key ordering, encoding, and formatting are fixed by canonical rules.
- All non-lite values MUST be eliminated or flattened during canonicalization.
- Records that cannot be canonically represented are rejected.
- Canonicalization does not interpret semantics, repair data,
  or infer structure beyond explicit key encoding.

Canonicalization marks the point where runtime flexibility ends
and kernel invariants begin.

***

## Tara Kernel: Hashing

- #MODEL
- Assigns deterministic and authoritative identities to **canonical TaraSON bytes**.

- Rules:
    - Hashes are derived **only** from canonical byte representations.
    - The same canonical bytes must always yield the same hash.
    - Different kernel stages may compute hashes for different scopes
    (record, segment, tape), but each hash binds a well-defined content scope.
    - Once content is committed, its hash becomes authoritative and immutable.
    - The kernel requires hashing to be 
        - deterministic
        - reproducible
        - verifiable against canonical bytes


***

## Tara Kernel: Appending

- #MODEL
- Appending is the only operation that introduces new semantic content into a Tape.
- Repacking may change physical layout but never changes Tape identity.

- Rules:
- Appending:
    - creates a new segment, or
    - extends the **active, uncommitted tail** of the current segment.
- Once a segment (or record) is committed, it is immutable.
- Immutability is enforced by **hash locking**:
    - committed records are bound to their canonical content hashes,
    - committed segments are bound to commit hashes derived from record hashes.
- Existing committed segments and records are never modified.
- Reordering, deletion, or in-place rewriting is forbidden.

***

## Tara Kernel: Reading

- #MODEL
- Reading reconstructs runtime records from bytes retrieved from Storage
  under kernel authority.

- Rules:
    - All reads return **StaticRecords** derived from committed kernel data.
    - Bytes returned by the backend are treated as **opaque** until validated by the kernel.
    - Canonical bytes are those byte sequences that successfully validate
      against kernel canonicalization, hashing, and commit invariants.
    - Returned records are reconstructed from validated canonical bytes
      and are byte-identical in content to those canonical representations.
    - Reading performs structural and integrity validation as a mandatory step.
    - Reading performs no semantic interpretation.
    - No inference, decoding, or domain-level meaning is applied.

***

## Tara Kernel: Content Integrity System

- #MODEL
- The kernel is responsible for enforcing content integrity **for committed and storage-grade content**.
- This responsibility is handled by the **Content Integrity System**.
- The Content Integrity System defines the conditions under which content is considered valid by the kernel.

- Under kernel authority, the kernel is the sole authority on whether content is:
	- correctly hashed with respect to its canonical representation,
	- structurally committed according to kernel commit rules,
	- and structurally valid with respect to kernel-defined invariants.

- Content outside kernel authority (pre-ingestion, runtime staging, or exported data) is not covered by these guarantees.

***

## Tara Kernel: Record Hash Enforcement

#MODEL

For every **committed record under kernel authority**:
- A content hash is mandatory.
- The hash MUST be derivable deterministically from the record’s canonical bytes.
- The stored hash MUST match the hash recomputed from those canonical bytes.

A record is considered invalid **under kernel authority** if:
- a required content hash is missing,
- or the recomputed hash does not match the stored value.

Notes:
- Runtime (dynamic) records MAY exist without hashes.
- Hash presence and validation become mandatory only at the commit boundary.
- Canonical bytes remain the sole source of identity; hashes are integrity witnesses derived from them.

***
## Tara Kernel: Input / Output Guarantees

- #MODEL #GUARANTEE

- Kernel guarantees are **postconditions of kernel operations**,
  not assumptions about backend behavior or storage correctness.

- Records violating active kernel invariants are rejected at the boundary where those invariants apply.
- Records that fail commit-time integrity checks are never appended to kernel-recognized Storage.
- Bytes read from a backend are treated as opaque until validated.
  Records reconstructed from bytes that fail storage-grade validation are rejected and never returned by kernel APIs.
- Corrupted, unverifiable, or inconsistent storage bytes may exist physically, but are never accepted as valid kernel content.
- The kernel never yields content it has not successfully validated against all applicable invariants.

## Tara Kernel: Content invariants

#MODEL #GUARANTEE
- content under kernel authority is never committed unless hash-locked,
- kernel APIs never yield content with invalid or unverifiable hashes,
- content that violates canonical, hash, or commit invariants is never treated as valid.


***

## Tara Kernel: Segment Commit Validation

- #MODEL
- A committed segment MUST contain at least one **commit record**.

#MODEL #GUARANTEE
- Committed records are validated by the kernel before being used.
- Segments whose committed records fail validation are rejected by the kernel.
- Detected corruption is never silently accepted by the kernel.

A commit record:
- binds the segment’s canonical record sequence to a content hash,
- is computed over the entire committed record set of the segment,
- defines the integrity identity of that committed segment state.

The kernel defines:
- the semantic role of commit records,
- how commit records are encoded,
- where commit records are located relative to segment content.

The kernel does not define:
- the specific hash algorithm used to compute commit hashes.

- Hash algorithms are treated as pluggable but MUST be deterministic,
  verifiable, and consistently applied within a kernel authority domain.


***

## Tara Kernel: Hash-Locked Content Invariant

#MODEL

All **committed** kernel content is hash-locked:

- Records are locked by hashes derived from their canonical representation.
- Segments are locked by commit hashes over their committed record set.
- Tapes are locked by hashes derived from the ordered content they expose.

The kernel guarantees:

- content without a verified hash is never treated as committed,
- invalid or mismatched hashes are never returned as valid content,
- corrupted records, segments, or tapes are rejected under kernel authority.

- Hashing is mandatory for commitment, but not for runtime data.
- The kernel mandate all committed content exposes verifiable, deterministic hashes derived solely from canonical bytes.

***

## Tara Kernel: Immutability

#MODEL #INVARIANT
- Segments and StaticRecords are immutable.
- Tape structure changes only via append

***

## Tara Kernel: Determinism

#MODEL #INVARIANT
- Canonicalization is stable.
- Hashing is deterministic.
- Identical input yields identical identity.

***

## Tara Kernel: No Semantic Interpretation

#MODEL #INVARIANT
- The kernel does not understand domain concepts.
- It manipulates TaraSON only as data.
- The only exeption are kernel fields and CommittedRecords
