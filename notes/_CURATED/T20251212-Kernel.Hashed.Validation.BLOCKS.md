## Tara Kernel Hashed Validation (KHV) — Overview

* #MODEL
* The kernel defines a **single, unified content validation scheme**.
* This scheme applies uniformly to:
    * individual records,
    * generic `RecordSequence`s,
    * and storage-grade `TapeSegment`s.
* Sequence validation is based exclusively on **content hashes**.
* Canonical bytes are relevant only for **record-level hash derivation**, not for sequence-level validation.

***

## KHV: Record-Level Validation

* #LAW
* Any record under kernel authority MAY be validated individually.
* Record validation consists of:
    * recomputing the record content hash from its canonical representation,
    * verifying that the stored or declared hash matches.
* This validation:
    * does **not** involve `CommitRecord`s,
    * establishes the correctness of a single record’s identity.
* API:
    * `#PROPOSAL`
    * `tk_validate(record)`
    * performs record content hash validation,
    * fails if canonical bytes and content hash disagree.

***

## KHV: Sequence-Level Validation

* #MODEL
* The kernel can validate any **ordered sequence of records** represented as a `RecordSequence`.
* Sequence validation operates on:
    * record content hashes,
    * not on canonical bytes.
    * `CommitRecord`s
* This allows efficient validation once record hashes are known or trusted.
* Sequence validation is expressed as a **rolling hash computation** over the ordered record hashes.

***

## KHV: CommitRecords and Validation Scope

* #MODEL
* Collection validation is bounded by `CommitRecord`s.
* A validation scope is defined by:
    * an **opening anchor hash** (`commit0`),
    * an ordered sequence of record hashes,
    * a **closing `CommitRecord`** (`commit1`).
* **Opening Anchor**
* The opening anchor:
    * MAY be explicitly provided via as a `CommitRecord`,
    * or MAY default to a kernel-defined **GENESIS hash**.
* The default opening anchor is valid for:
    * generic `RecordSequence`s,
    * runtime or user-defined sequences,
    * `TapeSegment`s (which are headless by design).
* ***Closing CommitRecord**
* #LAW
* A closing `CommitRecord` is **mandatory** for sequence validation.
* The closing commit:
    * binds the full validation scope,
    * defines the authoritative content hash of the sequence prefix.
    * The sequence rolling hash must match the Closing CommitRecord stored hash
* For storage-grade objects:
    * every valid `TapeSegment` MUST expose at least one closing `CommitRecord`.

***

## KHV: Rolling Validation Modes
* #MODEL
* The kernel defines minimal rolling hash validation semantics.
* Supported validation modes include:
* **Full Validation**
* Validate the entire `RecordSequence` from:
    * opening anchor → last `CommitRecord`.
* **Delta Validation**
* Validate a sub-range between:
    * two `CommitRecord`s inside the same `RecordSequence`.
* A single sequence MAY contain multiple `CommitRecord`s.

***

## KHV: TapeSegments as Specialized RecordSequences

* #MODEL
* A `TapeSegment` is:
    * a tape-scoped,
    * committed,
    * storage-backed `RecordSequence`.
* Segment validation:
    * uses the same general sequence validation algorithm,
    * with a default opening anchor,
    * and a mandatory closing `CommitRecord`.
* No special-case validation logic exists for segments.

***

## KHV: Unified Kernel Validation Interface
* #LAW
* The kernel exposes a single validation scheme across all levels.
* APIs:
    * `#PROPOSAL`
    * `tk_validate(record)`
    * validates a single record’s content hash.
    * `tk_validate(commit0, records, commit1)`
    * performs rolling validation over an ordered record sequence.
* Implementations MAY accept:
    * full record objects (deriving hashes internally),
    * or precomputed `record_hashes::Vector{Hash}` when record validity is already established.

***

## KHV: Kernel Guarantee

* #LAW
* This validation scheme is:
    * the **only** kernel-recognized content integrity mechanism,
    * used uniformly for runtime sequences, `TapeSegment`s, and tape-level integrity,
    * independent of storage backend, layout, or runtime representation.

***