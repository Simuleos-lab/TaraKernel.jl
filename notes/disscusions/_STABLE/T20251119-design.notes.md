***
# NOTE
- extracted from disscusing `git` development phylosophy
- > being wrong is worse than being inconvenient
- > Git deliberately exposes its plumbing. If you touch the plumbing, you must be responsible for consequences.
    - we need to clearly define the plumming
        - `TaraKernel`
    - and Separated from the applications on top
    - also, the plumming must be usable by itself
- #TODO
- Discuss about applying `git` philosophy to Simuleos design
    - eg. stage/commit workflow

- How this applies here
- “Where should I, as a developer, stop implementing auto-recoveries?”
    - Don’t guess user intent.
    - Don’t hide failures.
    - Make rules explicit.
    - Document the contract and trust users to follow it.
- You can offer helper commands
    - but avoid silently fixing in background.
- tools may help, but the core stays strict.
    - Same principle applies for TaraKernel vs ContextRecorders

***
# NOTE
- A good way to prompt awareness of what is being recorded
- Is to error any time a dict is transformed to TaraSON 
    - and it has non-lite values.
- The user is responsible for eliminating non-lite values  
    - or promoting them to 
        - lite representations.
        - lite links to `Artifacts`.
- Because the transformation is done on the final ContextRecord,  
  the filtering becomes an explicit part of the workflow.
- If after hooks the structure is still non-lite:
    - error
- Hooks are responsible for deciding **how** to transform non-lite scope values into lite contextual data, when meaningful.
- There will be a Simuleos interface for checking if a type is lite.

***
# NOTE
- Lessons from Perkeep
    - Content-named DB
        - Having content-named objects avoids duplication
        - Allows merging and synchronization without conflicts
    - For Tara, the focus is metadata (ContextRecords)
        - Heavy data is kept external and only referenced
        - If an external artifact loader breaks, the ContextRecord still preserves meaning
        - Lite context lets us be more ambitious about interpretation
        - Extensions for heavy data can happen later without affecting TaraSON

***
#### NOTE
- https://docs.ipfs.tech/concepts/what-is-ipfs/
- Check IPFS ideas for global content-addressed space

***
#### NOTE
- https://book.keybase.io/docs/files/details
- Check universal filesystem concepts

***
#### NOTE
- https://indieweb.org/PESOS  
    - You have no initial control of your data  
    - but you can recollect it and own it back.
- https://indieweb.org/POSSE  
    - You publish in your own domain, then allow others to republish.
    - Relevant as philosophy for recorder autonomy and interoperability.

***
#### NOTE
- Notes from this video  
    - https://www.youtube.com/watch?v=PlAU_da_U4s&t=742s

- Content-addressable files:
    - the index of a file is a hash of its content.

- Versions:
    - each version has a different hash
    - the version chain is a higher abstraction
    - The file is just content.


### NOTE
- There are two important components:
- `Scope`
    - captures program state at a moment  
    - belongs to the Recorder (Simuleos) layer  
- `ContextRecord`
    - a lite, canonical description of an Issue  
    - belongs to the Tara layer
- The objects serve different purposes but cooperate.
- They must remain separated;  
  but the flow **Scope → ContextRecord** is natural.

#NOTE
## What should it do
- Scope-aware code
    - Tools for working with captured scope
    - Scope-dependent callbacks (hooks)
        - Error if required hooks are not triggered
    - Scope-dependent filters
    - Type-dependent collection
        - derived from scope, but converted to lite form

- Flexible recording capability
- Implement a Dict-like interface for temporary holding (Scope)
- Recording must support batching
- Batching should be adjustable but ignorable when possible
- Use a Tape-like system for final storage 
    - Based on TaraKernel Tapes

- Global state objects when convenient
    - like Plots.jl style registries for Recorder configuration

- Context-specific memoization
    - only for Recorder internal use (not stored in ContextRecord)

- Context-specific hashing
    - canonical content hashing happens at the Tara layer

- Minimal code annotation
    - ex: `@sim_scope "label"`

- Convenient metadata for each recorded entity
    - timestamps, labels, recorder info
    - all must be lite and included in the ContextRecord

- Keep simulation code and recording code separated
    - Use callbacks for saving/capturing  
      without modifying simulation logic

- Respect simulation flow
    - No artificial loops for storage
    - Recording is event-based (`@sim_scope`)

- Full interface for interacting with stored data  
    (filter, map, delete, create)
    - Must operate on Tapes, not custom formats
    - Do not ReImplement anything sophisticated
        - Use external tools (rg. SQL-like stuff)

- Integration with git
    - useful, but optional for Recorder workflows
    - not a requirement of TaraKernel
    - we can envision a lot of different `ContextExtractors` from git trees. 

- #NOTE
- `ContextExtractors`
- Is a program that do not create information
- but, transcribe it to `Tara` compatible format
