***
# NOTE
- extracted from disscusing `git` development phylosophy
- > being wrong is worse than being inconvenient
- > Git deliberately exposes its plumbing. If you touch the plumbing, you must be responsible for consequences.
    - we need to clearly define the plumming
        - `TaraKernel`
    - and separate it from the applications on top
    - also, the plumming must be usable by itself
- #TODO/DONE
- Discuss about applying `git` philosophy to `TaraKernel` design
    - eg. stage/commit workflow

- How this applies here
- “Where should I, as a developer, stop implementing auto-recoveries?”
    - Don’t guess user intent.
    - Don’t hide failures.
    - Make rules explicit.
    - Document the contract and trust users to follow it.
- You can offer helper commands
    - but avoid silently fixing in background.
- tools may help, but the core stays strict.
    - Same principle applies for TaraKernel vs ContextRecorders

***
# NOTE
- A good way to prompt awareness of what is being recorded
- Is to error any time a dict is transformed to TaraSON
    - and it has non-lite values.
- The user is responsible for eliminating non-lite values
    - or promoting them to
        - lite representations.
        - lite links to `Artifacts`.
- Because the transformation is done on the final ContextRecord,
  the filtering becomes an explicit part of the workflow.
- If after hooks the structure is still non-lite:
    - error
- Hooks are responsible for deciding **how** to transform non-lite scope values into lite contextual data, when meaningful.
- There will be a Simuleos interface for checking if a type is lite.

***
# NOTE
- Lessons from Perkeep
    - Content-named DB
        - Having content-named objects avoids duplication
        - Allows merging and synchronization without conflicts
    - For Tara, the focus is metadata (ContextRecords)
        - Heavy data is kept external and only referenced
        - If an external artifact loader breaks, the ContextRecord still preserves meaning
        - Lite context lets us be more ambitious about interpretation
        - Extensions for heavy data can happen later without affecting TaraSON

***
#### NOTE
- https://docs.ipfs.tech/concepts/what-is-ipfs/
- Check IPFS ideas for global content-addressed space

***
#### NOTE
- https://book.keybase.io/docs/files/details
- Check universal filesystem concepts

***
#### NOTE
- https://indieweb.org/PESOS
    - You have no initial control of your data
    - but you can recollect it and own it back.
- https://indieweb.org/POSSE
    - You publish in your own domain, then allow others to republish.
    - Relevant as philosophy for recorder autonomy and interoperability.

***
#### NOTE
- Notes from this video
    - https://www.youtube.com/watch?v=PlAU_da_U4s&t=742s

***
# OUTDATED IDEAS
- *Implicit suggestion that IPFS / Keybase could be part of TaraKernel itself.*  
  These systems are now strictly **out of scope for the Kernel** and belong to upper layers.
- *Ambiguity about ContextRecord vs LiteRecord as separate types.*  
  The current architecture treats **ContextRecord = a LiteRecord used at Recorder level**, not a distinct structure.
- *Earlier implication that heavy data might later be embedded inside TaraSON.*  
  Current design fixes heavy data as **always external artifacts**, never embedded.
- *Any interpretation that “Scope == Context” at the Kernel level.*  
  Separation is now clear: Scope → Recorder layer, ContextRecord → LiteRecord at Kernel boundary.
