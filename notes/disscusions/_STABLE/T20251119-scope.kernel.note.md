# GENERAL GOAL
- Establish a Scope engine that captures program state through explicit markers.
- Provide a hook system that controls recording, interpretation, and Context extraction without affecting simulation semantics.
- Maintain strict separation between simulation code and recording configuration.
- Ensure the system remains simple, explicit, predictable, and failure-transparent.

---

## Scope Object
- Scope is a Dict-like snapshot.
- Scope includes globals from `Main` (related to environment introspection).
- Scope includes locals via `Base.@locals` (related to runtime state).
- Scope includes metadata under `_Simuleos.meta` (depends on capture moment).
- Scope stores `"key"`, `"val"`, `"src"` fields per variable.
    - #OPTIONAL
- Scope is treated as an intermediary object (related to Context extraction).
- Scope is intended to remain immutable for hooks (related to non-steering).
    - #IMPORTANT
- Scope may remain a plain Dict (reason: simplicity, transparency).
    - #OPTIONAL

---

## Labels
- Label keys follow by a prefix
    - `_sim_label_HASH`.
- Labels identify scope capture regions.
- Hooks may require presence of labels (depends on validation).
    - #PREFERED
- Missing labels should trigger errors (related to fail-loudly).
    - #PREFERED

---

## `@sim_scope` Intent
- Acts as the entry point for capturing a scope.
- Wraps simulation code minimally (related to non-intrusion).
- Should trigger scope capture, validation, hook invocation.
- No implicit behavior unless configured (connection to opt-in design).
- Exists to keep simulation code clean (related to separation of concerns).

---

## Hook System — Philosophy
### Explicitness & Opt-in
- All magic must be explicit.
- Hooks run only when registered.
- No default side effects (related to predictable behavior).

### Interpretation-only
- Hooks must not steer simulation (limitation).
- Hooks must not mutate the Scope (constraint).
    - #IMPORTANT 
    - for avoiding explosion of complexity
- Hooks are not replacements for Julia encapsulation (reason).
    - #IMPORTANT 
- Hooks only observe and describe (related to Context extraction).
    - #CROSSROAD 
    - Simuleos might deal with more than `Tara`s problems

### Failure Transparency
- Fail loudly rather than guessing.
- Errors on invalid lite constraints (related to Context formation).
- Errors on missing labels (depends on validation).
- Errors on hook conflicts (practical constraint).

### Single, Simple Input Object
- Hooks receive a single Scope Dict.
- Dict is easier to inspect and reason about (design choice).
- Avoids complex custom types (simplicity trade-off).
- Maintains clear plumbing visibility (related to git analogy).

### Non-interference Guarantee
- Hooks must not produce re-entrant scope captures unless explicitly allowed.
- Hooks should not alter live program data (strong separation).
- Hooks exist outside simulation flow (reason).

---

## Hook Roles
### Guard Hooks
- Validate scope before other processing.
- Enforce presence of labels.
- Enforce lite-ness constraints.
- Must error on violation (related to fail loudly).

### Transform Hooks
- Convert Scope → Context (depends on lite rules).
- May compute hashes or derived fields.
- Produce semantic representations without modifying Scope.

### Sink Hooks
- Record Context into LiteTapes (related to storage).
- Emit logs or telemetry.
- Save or route derived data externally.
- Errors must interrupt recording, not simulation (practical separation).

---

## Event Model
- Each `@sim_scope` produces a scope-captured event.
- Hooks subscribe via match rules (related to filtering).
- Matching can depend on labels, keys, value types.
- Simulation code emits events without knowing hook details (decoupling).

---

## Separation of Simulation Code and Recording Code
- Simulation file contains only `@sim_scope "label"` calls.
- Recording configuration registers hooks externally.
- Differentiates porcelain (simulation) from plumbing (recording).
- Minimizes maintenance burden on scientific workflows.

---

## Simplicity Constraints
- Avoid dependency graphs between hooks (simplicity).
- Avoid priority systems (fixed order: Guard → Transform → Sink).
- Avoid nested scope events unless explicitly enabled.
- Avoid global mutable state inside hooks except controlled caches.
- Preserve Dict-based Scope as long as feasible.

---

## Connections Summary
- Labels → required by Guard hooks.
    - This has double porpuse, 
- Scope → input for Transform hooks.
- Transform output → input for Sink hooks.
- Lite constraints → apply during Context extraction.
- Fail-loudly philosophy → governs all hook types.
- Opt-in principle → governs when hooks run.
- Separation of concerns → keeps simulation code clean.
- Dict-based Scope → keeps the model simple and transparent.