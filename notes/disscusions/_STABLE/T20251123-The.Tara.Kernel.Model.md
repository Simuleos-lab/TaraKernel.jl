## 1. What exists in the Tape kernel

1. **Tape**

   * A tape is a *finite, ordered sequence* of segments stored on durable media.

2. **Segment**

   * A segment is a chunk unit on a tape.
   * Any data of the tape must belong to a segment.
   * Each segment has:
     * a **position** on its tape (0, 1, 2, …) defining order,
     * a **payload**: a collection of `LiteRecord`s
        * on disk as a single `jsonl`, `TaraSON` compatible, file.
        * 1 segment → N records
     * optional **metadata** (e.g. type/kind tag, version, links).
        * a reserved `LiteRecord`


3. **LiteRecord**

   * The minimal in-memory structure representing a canonical TaraSON payload.
   * LiteRecords contain only lite fields (strings, numbers, booleans, small vectors, shallow dicts).

4. **StaticLiteRecord**

   * A LiteRecord loaded from a segment.
   * Immutable and associated with its originating segment.
   * The only record type exposed when reading from tapes.

7. **DynamicLiteRecord**

   * A mutable LiteRecord intended to be appended to a tape.
   * Once appended, it becomes a StaticLiteRecord.
   * Only one transformation path: Dynamic → canonicalization → Static.

---

## 2. What is *not* part of the Tape kernel

1. **Scopes**
   * Scopes belong to Recorder-level logic.
   * Kernel never receives or interprets Scopes.

2. **Issues**
   * Issues are a Recorder-level semantic concept.
   * Kernel stores only flat TaraSON records.

3. **Artifacts**
   * Heavy data is always handled outside the kernel.
   * Kernel only stores lite references as part of LiteRecords.

4. **Concurrency or transactional models**
   * Multi-process safety belongs to the environment and file-system semantics.
   * Kernel assumes append-only correctness without higher-level locking strategies.

5. **High-level querying**
   * Kernel supports simple iteration over StaticRecords.
   * Advanced queries occur in higher-level systems.

---

## 3. Kernel operations

1. **Canonicalization**

   * DynamicLiteRecord → canonical flat TaraSON object.
   * Deterministic key order and normalization.
   * Non-lite fields cause error before reaching the kernel.

2. **Hashing**

   * Hash is derived only from canonical TaraSON bytes.
   * Same canonical record → same hash.

3. **Appending**

   * Append creates a new segment or extends the active one.
   * Append is the only way to add records.

4. **Reading**

   * Reading always yields StaticRecords.
   * Records are returned exactly as they appear canonically.

5. **Repacking**

   * Produces a new tape with equivalent canonical record sequence.
   * Deduplication and segment re-organization allowed if IDs preserved.

---

## 4. Tape structure

1. **Segments**

   * Each segment is a standalone `.jsonl` TaraSON file.
   * Segment boundaries have no semantic meaning; they are physical groupings.

2. **Meta segment (segment 0)**

   * Contains tape-level metadata.
   * Must be valid TaraSON.
   * Kernel does not interpret user fields; only structural fields matter.

3. **User data segments (segments 1, 2, …)**

   * Contain sequences of canonical LiteRecords.

4. **Ordering**

   * Segments are ordered by index.
   * Records inside each segment are ordered as they appear.

---

## 5. Kernel invariants

1. **Immutability**

   * Segments and StaticRecords are immutable.
   * Tape structure can only change via append or repack.

2. **Determinism**

   * Canonicalization must produce stable output.
   * Hash must always match canonical bytes.

3. **No semantic interpretation**

   * Kernel does not understand “Issue”, “Scope”, “Context”.
   * It only sees TaraSON payloads.

4. **Consistency**

   * Tapes must be readable after crashes.
   * Meta can be reconstructed if missing, producing a new tape.

5. **Equivalence**

   * Two tapes are equivalent if they expand to the same ordered list of canonical records.

---

## 6. Minimal API surface

1. **open_tape(path)**  
   * Load tape directory and parse meta.

2. **append(tape, DynamicLiteRecord)**  
   * Canonicalize, hash, and append.

3. **iterate(tape)**  
   * Sequentially stream StaticRecords.

4. **repack(tape)**  
   * Produce logically equivalent tape with optimized segment layout.

5. **recover(path)**  
   * Rebuild meta from segments.
   * Produces a new tape identity.

---

## OUTDATED IDEAS

- **Store as an active semantic layer**  
  Removed assumptions implying the Store had semantic responsibilities; now it is only a directory helper.

- **Segment metadata as arbitrarily rich structures**  
  Trimmed language suggesting flexible metadata; kernel only preserves structural meta.

- **Implicit support for nested or complex record structures**  
  Removed hints contradicting the strict flat TaraSON model.

- **Any reference to kernel interpreting Scopes or Issues**  
  These belong entirely to the Recorder layer under the updated architecture.

- **Suggestions that DynamicLiteRecord could have additional modes or history**  
  Only a single transformation path is allowed in the current model.
