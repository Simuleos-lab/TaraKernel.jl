# Record Type/State Strategies**

## ** Core Problem**

* LiteTapes must support **records originating from different sources**:
  * **Loaded records** → come from an existing segment file.
  * **Newly created records** → originate from a Scope or external ingestion pipeline.

* These sources impose **asymmetric invariants**:
  * Loaded records naturally fit an **array-backed, segment-dependent** representation.
  * Newly created records need a **free-standing, segmentless** representation.

* The system must manage **record lifecycle**, **consistency**, and **invariants** without complex state flags.

---

## ** Strategy: Use Multiple Julia Types (Not a Single Type With State Flags)**

### Rationale

* Types encode invariants directly → fewer error conditions.
* Each record state has clearly defined behavior, allowed operations, and data location.
* Avoid large “mega-structs” with `state::Symbol` and conditional logic spread across the codebase.
* Keeps dispatch tables clean and aligns with tape semantics: append-only, immutable-after-commit.

### Core Principle

> **Record state should be represented by distinct types whenever the invariants or allowed operations differ meaningfully.**

---

## ** Essential Record Types**

### ** DynamicRecord**

* **Purpose**: Represents new, in-memory, mutable records before they are stored into a segment.
* **Characteristics**:

  * Segmentless.
  * Holds its own payload.
  * Created from Scopes or ingestion pipelines.
* **Why needed**:

  * Allows construction/editing without segment constraints.
  * Cleanly models the “pre-commit” phase.

---

### ** StaticRecord**

* **Purpose**: Represents records that have already been written to a segment.
* **Characteristics**:

  * Immutable.
  * Segment-backed by `(segment, index)` or other locator.
  * Payload lives in the segment’s depot.
* **Why needed**:

  * Guarantees tape invariants.
  * Naturally represents loaded data without duplication.
  * Enables efficient scanning, indexing, and deterministic behavior.

---

## ** Additional Useful Record Types**

### ** InvalidRecord**

* **Purpose**: Represents a record that exists but fails validation (schema mismatch, hash mismatch, corrupt JSON, etc.).
* **Characteristics**:

  * Data not reliable.
  * Metadata still accessible.
* **Why needed**:

  * Allows safe iteration without runtime crashes.
  * Makes validation explicit at the type level.

---

### ** TombstoneRecord**

* **Purpose**: Represents logical deletion within append-only media.
* **Characteristics**:

  * Payload suppressed or absent.
  * Metadata marks the deletion event.
* **Why needed**:

  * Supports delete semantics without breaking immutability.
  * Useful in indexing, synchronization, compaction.

---

### ** RemoteRecordProxy**

* **Purpose**: Represents records stored in a remote or alternative backend (e.g., IPFS, TaraSON tree).
* **Characteristics**:

  * Lazily fetches payload.
  * Carries remote locator.
* **Why needed**:

  * Enables multi-backend, distributed tapes.
  * Separates local/remote semantics cleanly.

---

### ** CachedRecord** *(optional)*

* **Purpose**: Wraps a remote or static record with a local cached payload.
* **Why needed**:

  * Combine performance with remote references.
* **Often unnecessary**:

  * Usually handled as an internal caching layer inside Static/Remote.

---

### ** OverlayRecord / DirtyRecord** *(optional)*

* **Purpose**: Represents modifications applied over an existing StaticRecord without committing yet.
* **Why needed**:

  * For versioning workflows or staged updates.
* **Often unnecessary**:

  * Higher-level tooling (edit sessions) can maintain overlays without polluting core record types.

---

### ** MetadataOnlyRecord** *(optional)*

* **Purpose**: Record containing only metadata; payload omitted intentionally.
* **Why needed**:

  * Fast metadata scans.
* **Often unnecessary**:

  * StaticRecord can lazily load payload; metadata-only scans can be done via loaders.

---

### ** PendingRecord** *(rare)*

* **Purpose**: Slot reserved for a record in the middle of a multi-phase write.
* **Why needed**:

  * If LiteTapes ever supports streaming or preallocation.
* **Usually handled**:

  * By transaction/write objects rather than record types.

---

### **1 ImportRecord** *(transitional, rarely needed)*

* **Purpose**: Temporary record in the middle of an ingest pipeline.
* **Why typically unnecessary**:

  * Can convert directly into DynamicRecord.

---

## ** Recommended Minimal Set**

For the LiteTapes core storage layer, realistically only **four** are needed:

* **DynamicRecord**
* **StaticRecord**
* **InvalidRecord**
* **TombstoneRecord** (if logical deletion is planned)

Optional fifth:
* **RemoteRecordProxy** (if multiple storage backends are part of Tara)

Everything else can be implemented:

* via higher-level layers (index, import, edit sessions), or
* via composition instead of more types.

---

## ** Guiding Principle for Future Growth**

> Introduce a new Record type **only** when the invariants or lifecycle of that state differ enough that sharing a type would create conditional logic, weakened invariants, or ambiguous semantics.

This keeps the system simple, predictable, and easy to evolve.

