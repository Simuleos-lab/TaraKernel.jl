## COMMIT HASHING MODEL — PREFIXHASH AND DELTAHASH  

## DEFINITION
- Defines the hashing scheme used by `CommitRecord`s in a `LiteTapeSegment`.
- Each commit carries two related hashes:
    - `PrefixHash`: hash of the entire segment content up to this commit.
    - `DeltaHash`: hash of the new fragment of records since the previous commit.
- Both hashes are derived from **StaticLiteRecord-level hashes**, not raw bytes.
- Enables:
    - strong full-snapshot identity,
    - fine-grained fragment identity,
    - cheap incremental commit-time updates.

---

## RECORD HASHES
- Every `StaticLiteRecord` has a **RecordHash**:
    - computed from its canonical TaraSON content,
    - stable and deterministic.
- All higher-level hashes (`DeltaHash`, `PrefixHash`) are built from **sequences of RecordHash values**.
- The raw serialization (jsonl, compression, etc.) is a backend detail; the logical identity is defined by RecordHash sequences.

---

## DELTAHASH

### Concept
- `DeltaHash` represents the **new fragment** of the segment:
    - all records appended since the last commit.
- It is the hash of the sequence of RecordHashes in that fragment.
- Captures the identity of a **local update** (delta), not the entire history.

### Formal Definition
- Let `Rᵢ` be `StaticLiteRecord` at logical index `i`.
- Let `H(Rᵢ)` be its (canonical) RecordHash.
- Suppose the previous commit ended at record index `k_prev`.
- Current commit ends at index `k_curr`.
- The **delta fragment** is records `R₍k_prev+1₎ … R₍k_curr₎`.
- Then:
    - The ordered RecordHash list for the delta is:
        - `[H(R₍k_prev+1₎), …, H(R₍k_curr₎)]`
    - `DeltaHash = HashDelta([H(R₍k_prev+1₎), …, H(R₍k_curr₎)])`
- `HashDelta` is a kernel-defined function (e.g. a Merkle-style or concatenation-based hash over the sequence of RecordHashes).

### Properties
- Identifies exactly the new records since the previous commit.
- The same fragment of records always yields the same DeltaHash.
- DeltaHashes are composable building blocks for repackaging and sub-segmentation.

---

## PREFIXHASH

### Concept
- `PrefixHash` is the **full segment hash** at this commit:
    - represents **all records from index 1** up to this commit index.
    - Inlclude all record types
        - `CommitRecord`s also
- Computed **incrementally** from DeltaHashes:
    - no need to rehash the entire history at commit time.
- Provides a strong, global identity for the whole prefix.

### Formal Definition
- Let commits be numbered `c = 1, 2, …, n`.
- Each commit `c` has:
    - `DeltaHash_c` for its local fragment.
    - `PrefixHash_c` for the full prefix up to that commit.
- Let `PrefixHash_0` be a fixed domain-separation seed (e.g. hash of empty sequence).
- Then:
    - `PrefixHash_1 = HashPrefix(PrefixHash_0, DeltaHash_1)`
    - `PrefixHash_2 = HashPrefix(PrefixHash_1, DeltaHash_2)`
    - …
    - `PrefixHash_c = HashPrefix(PrefixHash_{c-1}, DeltaHash_c)`
- `HashPrefix` is a kernel-defined function that combines the previous PrefixHash with the new DeltaHash (e.g. `H(PrefixHash_{c-1} || DeltaHash_c)`).

### Properties
- `PrefixHash_c` is a function of **all RecordHashes up to commit c**.
- Any change in any earlier record or delta invalidates all downstream PrefixHashes.
- PrefixHash provides:
    - full snapshot identity,
    - strong tamper detection,
    - simple “segment state at commit c” handle.

---

## COMMITRECORD CONTENTS

### Stored Fields
- Each `CommitRecord` stores at least:
    - `DeltaHash_c`: hash of new records in this commit’s fragment.
    - `PrefixHash_c`: full-segment hash up to this commit.
- Additional metadata may be stored (timestamp, author, policies, etc.), but does not affect the definition of the two hashes.

### Semantics
- `DeltaHash_c`:
    - describes “what was just added”.
- `PrefixHash_c`:
    - describes “what the entire segment now looks like”.
- During delta hashes computation, the new `CommitRecord` is considered as a derived data.
    - that is, it is not included on the hash computation
    - but previous `CommitRecord` are consider data to be hashed
- The `CommitRecord` is still a Record so
    - It hash its own `RecordHash`

---

## REPACKAGING AND FRAGMENTATION

### Using DeltaHash
- `DeltaHash_c` is the identity of a fragment between two commits.
- Fragments can be:
    - extracted,
    - moved into new segments,
    - grouped, deduplicated, or compressed.
- As long as the sequence of RecordHashes for the fragment is preserved, its DeltaHash remains valid.
- Enables “repackaging down” into smaller physical files or chunks.

### Using PrefixHash
- `PrefixHash_c` identifies a **complete view** of the segment up to commit `c`.
- Useful for:
    - full-state references,
    - stable snapshot linking,
    - high-level tape identity.

### Relationship
- All PrefixHashes are built from DeltaHashes.
- PrefixHashes give strong global guarantees.
- DeltaHashes give flexible, local guarantees.
- Users are encouraged to:
    - use `PrefixHash` when they need the full segment view,
    - use `DeltaHash` when they link or reason about sub-fragments.

---

## PERFORMANCE AND VERIFICATION

### Commit-Time Cost
- To commit:
    - compute RecordHashes for new records (if not already cached),
    - compute `DeltaHash_c` from those RecordHashes,
    - compute `PrefixHash_c` via `HashPrefix(PrefixHash_{c-1}, DeltaHash_c)`.
- Cost is proportional to the new fragment size only.
- No need to rehash the entire history at every commit.

### Full Verification
- Full verification from raw data:
    - recompute RecordHashes from canonical records,
    - recompute DeltaHashes,
    - recompute PrefixHashes in order.
- Cost is proportional to the total number of records, as expected for integrity checks.
- This is acceptable for occasional validation and audit tooling.

---

## SUMMARY (COMMIT HASHING MODEL)
- Each commit defines:
    - `DeltaHash` = hash of all RecordHashes in the new fragment.
    - `PrefixHash` = incremental hash of the entire segment up to this commit.
- DeltaHash provides fine-grained, fragment-level identity.
- PrefixHash provides full-prefix, snapshot-level identity.
- Both are built from RecordHashes, keeping identity tied to canonical content.
- This dual-hash model:
    - supports strong append-only semantics,
    - enables flexible repackaging and fragmentation,
    - keeps commit-time hashing cheap and incremental.
