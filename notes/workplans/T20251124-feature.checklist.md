# Implementation Workplan (Feature Checklist)

# **0. FOUNDATION / PROJECT SKELETON**

### **0.1 Base module structure**

* Create clear namespace separation: `LiteRecords`, `LiteTapes`, utilities.
* Ensure zero hidden state; only tapes and segments hold meaning.

### **0.2 Canonical TaraSON utilities**

* JSON-compatible canonical serializer.
* Deterministic key ordering, stable scalars, flat-only enforcement.

---

# **1. LITERECORDS LAYER**

### **1.1 Lite type validator**

* Function to verify whether values satisfy “lite discipline” (numbers, strings, booleans, small vectors, flat dicts).
* Errors on non-lite values during canonicalization.
  *Key consideration:* Fail-loud approach encourages explicit handling.

### **1.2 Canonical Record Representation**

* Implement canonical expansion rules for TaraSON records.
* Flatten nested structures via key names.
* Enforce deterministic serialization.

### **1.3 Record Type System**

Implement minimal set:

1. **DynamicRecord**

   * Free-standing, freshly created record; mutable until commit.
   * Used for ingest or Scope → Context workflows.

2. **StaticRecord**

   * Immutable record backed by a segment + index.
   * Storage-efficient representation for loaded records.

3. **InvalidRecord**

   * Wraps corrupted or schema-breaking segment payloads.
   * Prevents crash during iteration.

4. **TombstoneRecord** (optional, but recommended)

   * Logical deletion marker without violating immutability.

5. **RemoteRecordProxy** (optional)

   * Lazy remote-loading mechanism for distributed tapes.

### **1.4 Record hashing**

* **canonical.content.hash** (from deterministic expanded payload).
* **disk.content.hash** (raw on-disk bytes).
* **random.hash** (volatile runtime ID).
  *Key consideration:* naming must encode hash algorithm (Perkeep-style).

---

# **2. LITETAPES CORE LAYER**

### **2.1 Directory structure**

* `LiteTapeLib/` root folder.
* One folder per Tape.
* One file per segment (default `.jsonl`).
* System-reserved filenames (`tape.meta.jsonl`, lib meta).

### **2.2 LiteTapeLib meta**

* Store library identity, version, and list of Tape folders.
* Canonical TaraSON system segment.

### **2.3 Tape meta**

* Tape ID, creation time, format version.
* Ordered segment descriptor list.
* User metadata + structural metadata.
* Must be authoritative; cannot be derived reliably from segments.

### **2.4 System segment namespace**

Reserved types:

* `LiteTape.Meta`
* `LiteTape.Segment`
* `LiteTape.UserMeta`
* `LiteLib.Meta`
* `LiteLib.Tape`

*Key consideration:* meta is data, not code; kernel remains dumb.

---

# **3. SEGMENT LAYER**

### **3.1 Dynamic → Static segment lifecycle**

* DynamicSegment exists only during writing.
* Final segment sealed as immutable file then registered in meta.

### **3.2 Segment format**

* Payload: exactly one canonical TaraSON document.
* Metadata: minimal; type tags allowed but interpreted externally.
* Must round-trip to canonical form consistently.

### **3.3 Segment operations**

* **append_segment** — atomic append + meta update.
* **read_segment** — load and parse.
* **verify_segment** — validate canonical hash.
* **iterate_segments** — read in-order.

### **3.4 Recovery process**

* Rebuild meta by scanning segment files.
* Generates **new Tape identity**.
* Cannot guarantee full fidelity; meta is authoritative.

---

# **4. TAPE OPERATIONS & EQUIVALENCE**

### **4.1 Append-only invariant**

* Only add segments; never modify, delete, reorder.

### **4.2 Repack & compaction**

* Construct new equivalent Tape with deduplicated or reorganized segments.
* Maintain logical record order.
* Tape identity may remain or change depending on operation semantics.

### **4.3 Deduplication**

* Using `canonical.content.hash` to eliminate repeated ContextRecords.
* Must be lossless.

### **4.4 Equivalent Tape definition**

* Two Tapes equivalent if they expand to same ordered canonical record list.

---

# **5. READ API**

### **5.1 Basic iteration**

* Sequential read from position.
* Returns StaticRecords or InvalidRecords.

### **5.2 Whole tape scan**

* `read_all(tape)` built on sequential iteration.

### **5.3 Lookup**

* Optional index mapping `canonical.content.hash` → segment location.
* Built as derived convenience, not kernel state.

---

# **6. WRITE API**

### **6.1 New tape creation**

* Create folder, write meta segment 0.

### **6.2 Record commit flow**

DynamicRecord → canonicalize → generate hash → wrap into segment → append.

### **6.3 Update tape metadata**

* Controlled path: cannot arbitrarily overwrite meta.
* Only append, repack, or user-metadata operations are allowed.

---

# **7. TARA KERNEL RULE ENFORCEMENT**

### **7.1 Immutability rules**

* All StaticRecords and segments immutable.
* Append only; no in-place file changes.

### **7.2 Local semantics**

* Kernel interprets no semantic field; everything is raw TaraSON.

### **7.3 Schema evolution**

* Older canonical records must stay valid.
* New schemas must tolerate old ones.

### **7.4 Derivability rule**

* All higher-level structures must be derivable from segments + meta.

---

# **8. OPTIONAL EXTENSIONS (NOT CORE)**

### **8.1 Multi-backend storage**

* Pluggable resolvers for different backends (FS, cloud, IPFS).
* Must preserve Tape structure perfectly.

### **8.2 Ownership / cryptographic signatures**

* Perkeep-style signing of segments or tapes.
* Needs hash algorithm metadata.

### **8.3 Remote Tapes / distributed contexts**

* RemoteRecordProxy + remote index.
* Coordinate content-addressed segments across nodes.

---

# **9. TESTING & VALIDATION**

### **9.1 Lite discipline validator tests**

* Non-lite → error; lite → pass.

### **9.2 Segment correctness tests**

* Canonicalization idempotency.
* Hash stability.
* Load/round-trip.

### **9.3 Tape append/repack tests**

* Append-only invariants.
* Repack equivalence.
* Dedup correctness.

### **9.4 Recovery tests**

* Corrupt meta → rebuild meta → new Tape ID.

### **9.5 Stress tests**

* Many segments, mixed valid/invalid data.
* Large-scale canonical equality.
