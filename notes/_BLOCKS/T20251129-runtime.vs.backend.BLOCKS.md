
---
## RunTime/BackEnd: Kernel Boundaries and Canonical Bytes

The kernel operates across two layers:
### Runtime Layer

- Runtime objects (`AbstractLiteRecord`, `AbstractTapeSegment`, etc.) are:
  - structured
  - nested
  - flexible
  - host-language specific.
- They exist solely for:
  - manipulation
  - construction
  - validation
  - runtime convenience.

### Canonical Layer

- Canonical form is:
  - flat TaraSON,
  - stable bytes,
  - hashable,
  - equivalent across implementations.

### Input Boundary (read path)

```

BackEnd.bytes
→ Canonical bytes
→ Canonical records
→ Runtime objects

```

### Output Boundary (write path)

```

Runtime objects
→ canonical(record)
→ Canonical bytes
→ BackEnd.write

```

### Hashing Rule

All content hashes are computed from canonical bytes:

- never from runtime structure,
- never from backend format,
- never from storage layout.

Only canonical representation defines identity.

#DEV

---
## RunTime/BackEnd: RunTime Model

### IO

- The Kernel Base will anly deal with the `RunTime` representation
- It is a common interface which all Backends must connect to
- General workflows will be:
    - `BackEnd.Storage` -> `[Interface.read]` -> `cannonical.data.bytes` -> `[Kernel.parse]` -> `Kernel.objects` 
    - `Kernel.objects` -> `[Kernel.serialize]` -> `cannonical.data.bytes` -> `[Interface.write]` -> `BackEnd.Storage` 
    - `data.bytes` are just a collection of bytes
- The `BackEnd`s will be responsable of providing the bytes are loading, and reciving an storaging the bytes at writing.
- The `DiskBackend` provided by the `Kernel` is an example of one.
- The kernel core comminicate recieving/returning a byte collection

---
## RunTime/BackEnd: Working representation

**General**
- The working runtime representation is an interface for habdling `Kernel.objects`
- Here an example list of runtime `Kernel.objects` abstracts:
    - `AbstractLiteRecord`
        - Represent at runtime a single `TaraSON` derived entry 
        - Its runtime representation is flexible
        - but it must be canonazable to valid `TaraSON` bytes.
    - `AbstractTapeSegment`s
        - Represent a collection of `AbstractLiteRecord`s
        - An append-only object
        - Its runtime representation is flexible
        - but it must be canonazable to valid `TaraSON` bytes.
    - `AbstractLiteTape`s
        - Control a sequence of `AbstractTapeSegment`s
    - `AbstractTapeLibrary`
        - Control a sequence of `AbstractLiteTape`s

**Runtime Tree Model**

- The main objects at runtime are orginized on a acyclic tree
    - `AbstractTapeLibrary` <-> `AbstractLiteTape` <-> `AbstractTapeSegment` <-> `AbstractLiteRecord`
- This structure allows to transverse the data base
    - having a record, I can get the container segment, tape and lib
    - having a tape, I can iterate all its records in order

---
## RunTime/BackEnd: Backend Model

- Must cannonical bytes of a requested Tape segment
- Must store the cannonical bytes of a target Tape segment
- Must support appending workflow

---
