# Lite Boundary and No-Auto-Conversion Policy  
#GENERAL GOAL
- Define the responsibility of the Kernel regarding “lite” values.
- Establish the rule that **Kernel never converts user data into lite form**.
- Preserve a strict boundary between user-space projection and kernel-space validation.

---

# CORE RULE
- The Kernel **defines what is lite** and **validates** that all incoming values satisfy the lite discipline.
- The Kernel **never attempts to auto-convert**, promote, coerce, or serialize non-lite values into lite ones.
- Any non-lite value reaching Kernel APIs results in a **hard error**.

---

# RATIONALE
- Lite conversion is inherently domain-dependent and belongs entirely to user space.
- Different recorders and applications may use different projection strategies or conventions.
- Keeping conversion out of the Kernel:
    - prevents silent bugs,
    - makes validation predictable,
    - avoids unintended data shaping,
    - maintains a clean separation of concerns.

---

# PERMITTED VALUES
- The Kernel only accepts values that are already natively lite:
    - numbers, strings, booleans,
    - simple arrays/tuples/dicts composed of lite elements.
- No implicit promotion of complex or non-lite types is ever performed.

---

# USER RESPONSIBILITY
- Users (or higher layers like Simuleos) must define their own projection layer.
- User-space code decides how application objects become lite.
- Kernel involvement begins **only after** the data is already in its lite form.

---

# SUMMARY
- Kernel = define lite, check lite, reject non-lite.  
- User space = convert to lite, apply domain rules, prepare data before committing.  
- This creates a strict and predictable boundary that stabilizes all Recorder workflows.
