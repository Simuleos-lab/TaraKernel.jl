## 1. Design goals for LiteValue

If a ContextRecord is your atomic “unit of meaning”, LiteValues are the atoms that make it up. For that role, each value should:

1. **Round-trip everywhere**

   * Must serialize to a boring, standards-compliant JSON/TaraSON representation.
   * No runtime types, no language-specific objects, no implicit schema needed to parse it.

2. **Be cheap to move, copy, hash, and index**

   * A single value should be small enough that you don’t care about keeping many of them in RAM.
   * You can compute canonical hashes for millions of records without falling over.

3. **Be stable and deterministic**

   * Same logical value → same serialized representation → same hash.
   * No dependence on machine locale, time zone, RNG state, etc.

4. **Be self-contained and inspectable**

   * A human should be able to understand a LiteValue just by reading it.
   * If the referenced heavy data disappears, the LiteValue should still make sense.

5. **Be boring**

   * You want to be able to feed this into any tool (SQLite JSON, DuckDB, jq, Python, Julia, whatever) and have it “just work”.

Given those goals, here is what I would *define* as LiteValue.

---

## 2. Core “shape” definition

### 2.1 Allowed base types

I would allow these **primitive shapes**:

1. **Null / missing**

   * A single null sentinel (whatever TaraSON uses for “no value”).

2. **Booleans**

   * `true` / `false`.

3. **Numbers (restricted)**

   * Integers within a safe, explicit range (e.g. 64-bit signed).
   * Floating-point with clear rules:

     * No NaN, no ±Inf.
     * Canonical string format (e.g. fixed or scientific with defined precision).
   * Basically: anything that won’t stringify differently on different machines.

4. **Strings**

   * Unicode text in a canonical normalization form (or at least treated as opaque sequences).
   * Encodings and escaping rules fixed by TaraSON.

That already covers a huge fraction of “context”.

---

### 2.2 Allowed composite shapes

Then I’d allow **two composite forms**:

1. **Small arrays / lists of LiteValue**

   * Ordered sequences of LiteValue elements.
   * With **hard limits** on:

     * length (e.g. couple dozen elements by default),
     * nesting depth (e.g. arrays of arrays no deeper than 1–2 levels).
   * Idea: a small vector of parameters / small result vector is fine; a 10⁶-length simulation output is not.

2. **Small objects / maps with string keys**

   * Key → LiteValue maps.
   * Only string keys.
   * With **hard limits** on:

     * number of keys (e.g. tens, not thousands),
     * nesting depth (again, 1–2 levels at most).

Even if your canonical Record representation is “flat” at the top level, it’s still useful to let individual values be small structured blobs (e.g. a mini result summary) as long as they stay small and deterministic.

---

## 3. Quantitative constraints (the “lite” in LiteValue)

The shape alone isn’t enough; you need **size and complexity bounds**.

I’d attach something like:

1. **Size per value**

   * Bound on serialized byte size — for example:

     * “Any single LiteValue must serialize to at most N bytes” (N configurable, but default maybe 1–10 KB).
   * That automatically rules out large strings, big lists, etc.

2. **Aggregate constraints**

   * For each ContextRecord:

     * Total serialized size ≤ some budget (e.g. 64–256 KB).
     * Combined number of LiteValues (over all fields) ≤ some limit.

3. **Depth constraints**

   * Maximum nesting depth (arrays and objects) is small and fixed (say 3).
   * That keeps JSON pointer paths short and human-inspectable.

4. **Uniformity constraints (optional but nice)**

   * Arrays are encouraged to be fairly homogeneous (all numbers, or all objects with similar shapes) to keep indexing/querying simple.
   * Not enforced strictly, but a good design smell check.

These constraints are *soft policy* in the sense that they’re enforced by validators, not the type system.

---

## 4. Explicitly *not* LiteValue

Here’s what I’d push out of LiteValue territory:

1. **Language-specific objects**

   * Julia structs, Python objects, function handles, closures, etc.
   * Even if they can be stringified, their semantics aren’t universal.

2. **Heavy data**

   * Large arrays, matrices, tensors.
   * Raw binary blobs.
   * Any large JSON tree.

3. **Non-deterministic or environment-dependent encodings**

   * Values whose string form depends on locale, timezone, process state, RNG, etc.
   * E.g. `TimeZoneLocalNow()` as a raw string without specifying TZ is already suspect; it’s better as a timestamp number in a fixed format.

4. **High-dimensional or high-precision numeric fields**

   * Arbitrary precision decimals or rationals: okay only if you fully specify their canonical serialization and can guarantee cross-implementation consistency. Otherwise they’re “non-lite”.

5. **Opaque identifiers that hide all semantics**

   * A giant opaque string that is really a base64-encoded binary blob.
   * Better to treat that as an Artifact reference and record a lite descriptor around it.

---

## 5. Operational rules LiteValue should follow

Apart from type/shape, I’d define LiteValue by what operations you can safely rely on:

1. **Stable equality**

   * Two LiteValues can be compared for structural equality (same type, same structure, same contents) and that equivalence is meaningful and portable.

2. **Stable hashing**

   * You can always compute a canonical hash from its canonical serialization.
   * That hash works as a building block of the ContextRecord hash.

3. **Cheap duplication**

   * Copying a LiteValue is cheap enough that you don’t think twice (no file handles, no huge buffers).

4. **Serializable everywhere**

   * It can go through:

     * TaraSON,
     * JSON parsers,
     * generic data tools (e.g. SQLite’s JSON1),
     * and come back intact.

If a candidate value fails any of these, it probably isn’t “lite”.

---

## 6. Short, opinionated definition

If I had to compress all this into one design sentence:

> **A LiteValue is any small, fully serializable, deterministic JSON-like scalar or tiny structure whose entire meaning is self-contained and cheap enough to duplicate, hash, and inspect by eye.**

Everything “heavier” (large arrays, binaries, opaque blobs, tool-specific objects) gets pushed into **Artifacts** referenced by LiteValues, not embedded as LiteValues themselves.