# Tara Tape Kernel — Specification

## Scope and Purpose

The Tape kernel is the minimal component responsible for "legally" moving records between:

- `StoreBackend.Tape` → `TaraKernel` → `RunTime.Record`
- `RunTime.Record` → `TaraKernel` → `StoreBackend.Tape`

Whatever is **fundamental for doing this function** belongs in the kernel.  
Whatever is not fundamental **must be outside** the kernel.

The kernel:

- operates over **Tapes** and their segments,
- consumes and produces **runtime records**,
- enforces canonicalization, hashing, committing, and validation,
- guarantees a small set of invariants.

Higher-level meaning (Issues, Scopes, Contexts, etc.) is explicitly **out of scope**.

---

## In-Kernel Objects

### Tape

A **Tape** is a **finite, ordered sequence of segments** stored somewhere, somehow.

- The storage substrate is abstract.
- A Tape’s identity and semantics are defined purely by:
  - the ordered sequence of its segments,
  - the canonical records obtained from those segments.

---

## Out-of-Scope Responsibilities

The following concerns are explicitly **not** part of the Tape kernel.

### Artifacts and Heavy Data

- Heavy data is always handled **outside** the kernel.
- Artifact references are stored as regular TaraSON fields.
- For the kernel, a link is just data and carries no special semantics.

### Concurrency and Transaction Models

- Multi-process safety and locking belong to storage backends and the environment.
- The kernel assumes append-only correctness.
- Race conditions are the responsibility of the user and runtime environment.

### High-Level Querying

- The kernel query capability most remaind limited, like **simple iteration**.
- Advanced querying occurs outside the kernel.

---

### Canonicalization

Converts runtime records into canonical TaraSON.

- Input:
  - runtime records (DynamicLiteRecord or equivalent)
- Output:
  - canonical flat TaraSON object

Rules:

- Key order and representation must be deterministic.
- Non-lite values are rejected at all kernel boundaries:
  - input (creation / read),
  - output (write).

---
### Hashing

Assigns deterministic identities to TaraSON bytes.

Rules:

- Hashes are derived from TaraSON bytes.
- The same bytes must always yield the same hash.
- Many hashed representations may exist in different pipeline stages.
- The kernel only requires that each hashing use is deterministic.

---

### Appending

Appending is the only way to change a Tape.

Rules:

- Appending:
  - creates a new segment or
  - extends the active one.
- Existing segments and records are never modified.
- Reordering or deletion is forbidden.

---

### Reading

Reading yields records exactly as stored.

Rules:

- All reads return **StaticRecords**.
- Returned records are byte-identical to canonical storage.
- No interpretation, inference, or semantic decoding is performed.

---

## Content Integrity System

The kernel is responsible for enforcing content integrity at all structural levels.

This responsibility is handled by the **Content Integrity System**.

The kernel is the authority on whether content is:

- correctly hashed,
- structurally committed,
- and internally consistent.

---

### Record Hash Enforcement

For every record:

- A content hash is mandatory.
- The stored hash must match the hash recomputed from canonical bytes.

A record is invalid if:

- the hash is missing,
- or the recomputed hash differs from the stored value.

Kernel guarantees:

- Invalid records are rejected at input.
- Invalid records are never appended.
- Invalid records are never returned.

---

### Segment Commit Validation

Each segment MUST expose at least one **commit record**.

A commit record:

- binds segment content to a content hash,
- depends on its full segment scope,
- defines the integrity identity of the segment scope.

Kernel guarantees:

- Commit records are validated before use.
- Invalid segments are rejected.
- Corruption is never silently accepted.

The kernel do define:
- how commits are encoded,
- where they are stored,

But do not define:
- what hash algorithm is used.

---

### Tape-Level Hashing

A Tape has a content identity derived from:

- its ordered segments,
- each verified for integrity.

Kernel guarantees:

- Appending changes tape identity.
- Repacking does not change identity.
- Any invalid segment invalidates the tape.

Identity depends only on content, not physical layout.

---

### Hash-Locked Content Invariant

All kernel-managed content is **hash-locked**:

- Records are locked by content hashes.
- Segments are locked by commit hashes.
- Tapes are locked by structural hashes.

The kernel ensures:

- unlocked content never reaches storage,
- invalid hashes are never returned,
- corrupted structures are never treated as valid.

The kernel does not mandate *how* hashes are computed —  
only that they exist, are verified, and are enforced.

---

## Kernel Invariants

### Immutability

- Segments and StaticRecords are immutable.
- Tape structure changes only via append or repack.

---

### Determinism

- Canonicalization is stable.
- Hashing is deterministic.
- Identical input yields identical identity.

---

### No Semantic Interpretation

- The kernel does not understand domain concepts.
- It manipulates TaraSON only as data.

---

### Consistency

- Tapes remain readable after crashes.
- Metadata can be reconstructed from segments.
- Reconstruction must preserve record order.

---

### Tape Equivalence

Two tapes are equivalent iff:
- they expand to the same ordered list of canonical records.
Layout, segmentation, or storage backend do not affect equivalence.
