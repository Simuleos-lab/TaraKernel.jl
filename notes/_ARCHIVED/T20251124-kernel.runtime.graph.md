# Kernel RunTime Graph

- The **Kernel RunTime Graph** is the in-memory object graph built by TaraKernel when working with tapes on local disk.
- It is analogous to the **DOM** in web development:
  - The **canonical source of truth** is on disk (files, directories, JSONL segments).
  - The **runtime graph** is a navigable object structure built from that source, used for inspection, iteration, and operations during a process.
- The runtime graph is:
  - **Ephemeral**: rebuilt per process, not serialized as part of the data model.
  - **Local**: valid only inside the current Julia process.
  - **Non-canonical**: not part of TaraSON; it is a convenience API over the canonical disk representation.

---

## Canonical vs RunTime Layers

- Canonical layer:
  - Defined by the **on-disk representation**:
    - Tape directories.
    - Segment files.
    - Segment payloads (collections of lite, flat `LiteRecord`s as JSONL / TaraSON-compatible lines).
  - Contract:
    - Append-only tape semantics.
    - Lite/flat record invariants.
    - Content-addressable semantics (via canonical record representation and hashing).
- RunTime layer:
  - Defined by **Julia objects** that mirror and navigate the canonical structure.
  - Provides:
    - Convenient navigation: record -> segment -> tape.
    - In-memory caching of parsed records.
    - Iteration and querying APIs.
  - RunTime objects must be **derivable** from the canonical disk layout.

---

## RunTime Graph Nodes

At minimum, the Kernel RunTime Graph contains these node types:

- **LiteTapeLib (runtime)**
  - Represents a **library** of tapes rooted at a local directory.
  - Knows:
    - Library root path on disk.
    - List of loaded `LiteTape` runtime objects.
  - Responsibilities:
    - Discover tapes under the root.
    - Load/unload tape graphs as needed.
    - Provide a stable local context for a set of tapes.

- **LiteTape (runtime)**
  - Represents a **single tape** (append-only sequence of segments) stored under a directory.
  - Knows:
    - Tape directory path.
    - Ordered list of `LiteTapeSegment` runtime objects.
    - Tape-level metadata (from reserved metadata records and/or meta files).
  - Responsibilities:
    - Preserve the **segment order**.
    - Provide tape-level operations (iterate all records, append segment, etc.).
    - Act as the parent for all segment nodes.

- **LiteTapeSegment (runtime)**
  - Represents a **segment** (chunk unit on a tape).
  - Knows:
    - Reference to its parent `LiteTape`.
    - Segment position on the tape (0, 1, 2, …).
    - File path to the segment file on disk.
    - A collection of `StaticLiteRecord` runtime objects (segment payload).
    - Segment-level metadata (via reserved metadata record and/or flags).
  - Responsibilities:
    - Load and cache the segment payload (parse JSONL -> records).
    - Preserve the **record order** inside the segment.
    - Provide segment-level iteration, filtering, and summary operations.

- **StaticLiteRecord (runtime)**
  - Represents a **single lite, flat, immutable record** (logical LiteRecord) in memory.
  - Knows:
    - The validated record content (lite, flat map).
    - Optionally, runtime-only references to:
      - Parent `LiteTapeSegment` (if loaded from a segment).
      - Index within the segment payload (0, 1, 2, …).
  - Responsibilities:
    - Provide a **dict-like**, read-only interface to the record content.
    - Enforce lite/flat invariants at construction.
    - Act as the canonical in-memory representation of a record, regardless of whether it is attached to a tape yet.

---

## Edges and Navigation

- **Library-level edges**
  - `LiteTapeLib` -> `LiteTape`
    - A library has many tapes.
  - Navigation:
    - From `LiteTapeLib`, we can list all known tapes.
    - From a `LiteTape`, we can ask for its owning library (runtime-only).

- **Tape-level edges**
  - `LiteTape` -> `LiteTapeSegment`
    - A tape has many segments, ordered by **position**.
  - Navigation:
    - From `LiteTape`, we can iterate segments in logical tape order.
    - From `LiteTapeSegment`, we can access its parent `LiteTape`.

- **Segment-level edges**
  - `LiteTapeSegment` -> `StaticLiteRecord`
    - A segment’s payload is a collection of `StaticLiteRecord`s (including reserved metadata records).
  - Navigation:
    - From `LiteTapeSegment`, we can iterate the records in order.
    - From `StaticLiteRecord`, we can access its parent `LiteTapeSegment` (runtime-only) and its index inside the segment.

- **Record-level edges**
  - `StaticLiteRecord` (attached) -> `LiteTapeSegment` -> `LiteTape` -> `LiteTapeLib`.
  - For **unattached** `StaticLiteRecord`s (pre-commit):
    - No parent segment or tape; navigation edges are `nothing`.
    - They become attached only upon commit to a tape/segment.

---

## Ownership and Caching

- **Record content ownership**
  - Each logical record has **one** `StaticLiteRecord` runtime object per process.
  - A `LiteTapeSegment` owns the collection of `StaticLiteRecord`s in its payload.
  - Other parts of the code receive references to these `StaticLiteRecord`s, not copies.
- **No forced duplication**
  - On disk:
    - Deduplication is handled at the canonical record level (content hashing and indexes).
  - In memory:
    - Each record’s content exists once as a `StaticLiteRecord` object within its segment’s payload vector.
    - Multiple references can point to that object (from the segment, from iterators, from user code).
- **Lazy loading**
  - Segment payloads (records) may be loaded lazily:
    - Segment knows the file path and can parse JSONL on-demand.
    - Once loaded, the `StaticLiteRecord` objects are cached in the segment’s payload vector.

---

## Runtime vs Canonical Fields

- **Canonical fields** (appear in TaraSON / disk representation)
  - Record content (lite, flat maps).
  - Segment payloads (collections of records in JSONL).
  - Tape structure (segment files and order).
  - Tape and library metadata (represented as records and/or meta files).
- **RunTime-only fields** (not serialized, process-local)
  - Backreferences:
    - `StaticLiteRecord` -> `LiteTapeSegment`.
    - `LiteTapeSegment` -> `LiteTape`.
    - `LiteTape` -> `LiteTapeLib`.
  - In-memory indices:
    - Record index within segment payload.
    - Segment index within tape.
  - Parsed caches:
    - In-memory representations of segment payloads.
  - Any direct Julia object references (e.g. file handles, open streams).

- **Rule**
  - The Kernel RunTime Graph must be **fully reconstructible** from the canonical disk layout.
  - No essential semantic information may exist only in the runtime graph.

---

Here is a rewritten version of that section, incorporating the new idea:

---

## DiskBackend as Reference Implementation and Default Backend

* The **Kernel provides one concrete backend**, called the **DiskBackend**, which serves both as:

  * the **default backend** used by all Kernel operations, and
  * the **reference implementation** that defines the canonical semantics of tapes, segments, and records.

* **DiskBackend** defines the *authoritative* interpretation of:

  * what a tape is (a directory on a local filesystem),
  * what a segment is (a file such as `.jsonl` or a compressed variant),
  * how segment payloads are stored (TaraSON-compatible LiteRecords in JSONL),
  * how the Kernel RunTime Graph is built and navigated (library → tapes → segments → records).

* All core functionality in TaraKernel—append-only semantics, lite/flat validation, canonical hashing, segment ordering, and iteration—are specified **in terms of the DiskBackend model**.
  This gives the Kernel a single, simple, concrete ground truth.

* **Out of scope for the Kernel itself**:

  * remote stores (IPFS, S3, SSH, HTTP, etc.),
  * distributed or replicated backends,
  * synchronization, networking, or virtual filesystems.

  These concerns are left for **external packages** or **higher layers** that build on top of the Kernel.

* The Kernel **does not prohibit** additional backends. Instead, it provides:

  * a **clear runtime graph structure** (library → tapes → segments → records),
  * **generic names** (`StaticLiteRecord`, `LiteTape`, `LiteTapeSegment`) used by the DiskBackend,
  * and **well-defined invariants** that any backend may adopt if it wishes to be Tara-compatible.

* Other implementations—external or future Kernel extensions—may:

  * define their own backend modules (e.g., `IPFSBackend`, `MemoryBackend`, `RemoteBackend`),
  * provide objects mirroring the same runtime graph shape,
  * translate their own physical representation into the canonical LiteRecord model,
  * or materialize their content as DiskBackend tapes when needed.

## **Consequence**

  * The DiskBackend *anchors* the semantics of TaraKernel.
  * The canonical on-disk format (directories, segment files, JSONL/TaraSON payloads) is always defined through the DiskBackend.
  * The RunTime Graph’s shape and behavior are derived from the DiskBackend’s concrete structure.
  * Alternate backends must adapt to this structure, but the Kernel itself remains simple, local, and filesystem-driven.
