# TaraSON.Spec  

# GENERAL GOAL
- Define the complete and final specification of **TaraSON**, the canonical flat serialization format use by **The Tara Project**.
- Provide a precise, deterministic, language-agnostic data model.
- Ensure the format is suitable for 
    - hashing
    - content addressing
    - deduplication
    - interchange and long-term preservation.
- Represent all structure explicitly through canonical keys, without implicit semantics.

---

# PURPOSE
- Define how **a single TaraSON Record** is encoded.
- Define how **multiple TaraSON Records** may be stored (e.g., line-oriented `jsonl` style).
- Make the canonical layer extremely small, universal, and stable.
- Allow different languages and runtimes to produce TaraSON by flattening higher-level structures.
- Ensure deterministic equality (byte-level identical) across implementations.
- Provide the foundation for content addressing, replication, and integrity checks.

---

# RELEVANT IDEAS
- TaraSON is a **flat JSON object**: `StringKey → PrimitiveValue`.
- Keys encode structure through a **JSON Pointer–compatible path grammar**.
- Values must be **lite**, i.e., JSON-primitive values.
- No arrays, nested dicts, or composite values exist inside TaraSON itself.
- Canonicalization rules produce an ordered, deterministic encoding.
- Applications may use nested structures, but they must flatten before producing TaraSON.
- The canonical form is directly hashable.

---

# TaraSON — DEFINITION
- TaraSON is a **flat JSON object** representing a finite set of key–value pairs.
- All values are **JSON-primitive literals**:
    - string, number, boolean, null.
- All keys are **JSON Pointer–compatible path grammar**
    - canonical key model
- TaraSON does **not** directly allows nested arrays or objects.
- TaraSON does **not** directly allows composite values.
- TaraSON is intended to preserve **pure facts**, not structure.

---

# TaraSON — CANONICAL KEY MODEL
- Keys are encoded using **JSON Pointer–style absolute paths**.
- A canonical key always begins with `/`.
- Each key segment is escaped using RFC-6901 rules:
    - `~` → `~0`
    - `/` → `~1`
- Key segments may contain arbitrary Unicode strings after escaping.
- Canonical keys define structure implicitly:
    - `/a/b/c` means “key `c` inside path `a → b`”.
- Keys are globally unique within one record: no duplicates allowed.
- Keys represent **flattened paths**, which might come from arbitrary nested data defined in the runtime.

---

# TaraSON — VALUE MODEL
- Values must be **lite primitives**:
    - `"string"`
    - `123` (integer or float)
    - `true` / `false`
    - `null`
- No arrays, no objects, no tuples, no named tuples.
- Every value is a final, non-expandable leaf.
- Primitive sets are stable across all languages.

---

# TaraSON — RUNTIME REPRESENTATION VS CANONICAL REPRESENTATION
- Runtimes (Julia, Python, JS, etc.) may represent data using:
    - Dicts
    - Arrays
    - Structs
    - Tuples
    - NamedTuples
- Before producing TaraSON, runtimes must convert (“flatten”) those forms into a:
    - flat map `String → PrimitiveValue`
- Runtimes may reconstruct nested structure from canonical keys if needed.
- Runtimes may add metadata, types, shapes, or tags—none of these enter TaraSON.
- TaraSON is not responsible for type preservation.

---

# TaraSON — CANONICAL SERIALIZATION RULES
- A canonical TaraSON record is serialized as:
    - A `{ ... }` JSON object
    - Containing only primitive values
    - One key per entry
    - Keys sorted lexicographically by byte order
    - Deterministic whitespace rules (minimal JSON: `{"a":1,"b":2}`)
- Canonical serialization must be:
    - exactly reproducible by any compliant implementation
    - byte-stable across languages

---

# TaraSON — FREE REPRESENTATION

- A “free” TaraSON representation is any JSON object encoding the same flat set of facts but not necessarily canonical.
- Free representations:
    - may contain different whitespace,
    - may use different ordering,
    - may include equivalent encodings of numbers.
- Free representations are semantically equivalent to their canonical form if flattening and re-serialization yields the same canonical record.
- The canonical form is the identity reference.

---

# TaraSON — EQUALITY
- Two TaraSON records are equal if and only if:
    - their canonical representation is bytewise identical.
- Equality is independent of:
    - runtime structure,
    - original JSON layout,
    - ordering of keys in free form.

---

# TaraSON — HASHING (FORMAT-LEVEL, NOT KERNEL-LEVEL)
- TaraSON does not mandate a specific hashing algorithm.
- TaraSON requires that the canonical byte representation is the input to any hash chosen by a system.
- TaraSON recommends (but does not require):
    - SHA-256
    - Multi-hash descriptors (e.g., `sha256-abc123`)
- TaraKernel implements its own hashing policy, but that is outside this spec.

---

# TaraSON — STABILITY AND LONG-TERM CONSTRAINTS
- Keys and values must remain valid across:
    - languages,
    - versions,
    - national encodings,
    - environments.
- No reliance on:
    - binary floating formats,
    - locale-dependent number formatting,
    - implicit nesting semantics.
- The spec must remain fully backward compatible indefinitely.

---

# TaraSON — LIMITATIONS
- No direct support for:
    - arrays (must flatten),
    - structured objects (must flatten),
    - semantic schemas (must be handled by higher layers).
- TaraSON does not support comments or trailing commas.
- TaraSON cannot encode infinity, NaN, ±inf, or special language types.

---

# TaraSON — TRADEOFFS
- Flat structure simplifies hashing and deduplication while expressing structure explicitly through keys and sentinel markers rather than nested syntax.
- `JSON-Pointer` ensures universal parseability but may require escaping of segment characters.
- Runtime reconstruction of objects becomes more complex but fully doable.
    - `JSON-Pointer` paths encode any JSON structure directly, so no structural information is lost.
    - Complex hierarchical or non-JSON-native shapes are expressed through the path segments rather than values.
- Compression compensates for repetition in long prefix paths.
- Deterministic flat representation improves portability.
- Sentinel pairs `{}` and `[]` make container boundaries explicit, enabling full round-trip reconstruction but adding additional entries per container.

---

# TaraSON — CONNECTIONS
- Related to:
    - JSON Pointer (RFC-6901)
    - JSON (RFC-8259)
    - JSONL (line-oriented JSON)
- Indirectly influenced by:
    - IPFS/IPLD ideas about content addressing
    - Perkeep’s fact-style and schema-agnostic design

---

# TaraSON — EXAMPLES

### Simple canonical record
```

{
"/name": "Alice",
"/age": 30,
"/active": true
}

```

### Nested structure flattened
Runtime object:
```

{
"user": {
"id": 5,
"info": { "email": "[x@y.com](mailto:x@y.com)" }
}
}

```

Canonical TaraSON:
```

{
"/user/id": 5,
"/user/info/email": "[x@y.com](mailto:x@y.com)"
}

```

### Array flattening
Runtime:
```

{"items": [10, 20, 30]}

```

Canonical:
```

{
"/items/0": 10,
"/items/1": 20,
"/items/2": 30
}

```

---

# TaraSON — ROLE IN SYSTEMS
- TaraSON is a **file format**.
- TaraSON defines **no semantics about storage**, order, or immutability.
- TaraSON documents carry **no metadata beyond the key–value facts**.
- TaraKernel uses TaraSON as its record substrate, but this does not influence the format.
- Any system can store TaraSON:
    - inside files,
    - in databases,
    - over the network.

---

# OPTIONAL ELEMENTS
- Support for UTF-8 encoded strings.
- Canonical serialization may optionally require strict UTF-8 normalization (NFC).
- Systems may annotate TaraSON files externally with metadata, but never inside the TaraSON object.

---

# USAGE
- As a minimal, stable, universal interchange format.
- For deterministic hashing and deduplication.
- As a substrate for context recording and event logging.
- As an audit-friendly format resistant to historical rewriting.
- As a lowest-common-denominator representation for structured data.
