## 1. What exists in the Tape kernel

1. **Tape**

   * A tape is a *finite, ordered sequence* of segments stored on durable media.

2. **Segment**

   * A segment is the smallest indivisible unit on a tape.
   * Each segment has:
     * a **position** on its tape (0, 1, 2, …) defining order,
     * a **payload**: a single TaraSON document,
     * optional **metadata** (e.g. type/kind tag, version, links).
   * A segment may *refer* to other segments (by id, hash, or address), but those references are just data in its payload.

3. **Store**

   * A store is a collection of tapes.
   * The kernel does not require any particular indexing scheme over the store; it only assumes that tapes can be read from start to end.

---

## 2. Core operations

The Tape kernel assumes only a small set of primitive operations:

1. **Append**

   * `append(tape, payload, metadata) → segment`
   * Appends one new segment to the *end* of a tape.
   * Returns the newly created segment (or its identifier).

2. **Sequential read**

   * `read_from(tape, position) → stream of segments`
   * Yields segments in ascending position order, starting at `position`.

3. **Whole-tape read (shorthand)**

   * `read_all(tape) → stream of segments`
   * Equivalent to `read_from(tape, 0)`.

4. **Optional: lookup**

   * `lookup(store, segment_id) → segment or nothing`
   * This may be implemented via auxiliary indexes, but the kernel does not depend on *how*.

Everything else (indexes, queries, graphs, etc.) must be expressible as combinations of these operations.

---

## 3. Invariants and rules

These are the “laws” of the Tape kernel.

1. **Immutability**

   * Once a segment is appended to a tape:

     * its payload and metadata never change,
     * its position on the tape never changes.
   * There is no in-place update or deletion at the kernel level.

2. **Append-only growth**

   * The only way to change a tape is to append new segments at the end.
   * The sequence of existing segments is never shortened or reordered.

3. **Total order per tape**

   * For any two segments on the same tape, exactly one of:

     * `pos(a) < pos(b)` or `pos(a) > pos(b)` holds.
   * This gives a strict total order of segments along each tape.

4. **TaraSON payload validity**

   * The payload of every segment is a valid TaraSON document.
   * The kernel does not interpret the contents of TaraSON; it only guarantees that the bytes represent valid TaraSON.

5. **Local semantics only**

   * The kernel’s behavior depends only on:

     * the sequence of segments on tapes,
     * the bytes stored there.
   * It does *not* depend on any external mutable state.
   * Any additional state (indices, caches) is treated as a derived convenience layer, not part of the kernel.

6. **Derivability**

   * Any higher-level representation used by Simuleos (graphs, tables, indexes, caches) must be *derivable* from the set of segments in the store.
   * If all such higher-level structures are deleted, they can be reconstructed by reading tapes and reprocessing their segments.

7. **No hidden semantics**

   * All semantically meaningful information for Simuleos must be present in TaraSON payloads (and/or their simple metadata).
   * If something is not encoded in segments, the Tape kernel does not “know” it.

8. **Monotonic information growth**

   * New segments may:

     * add information,
     * supersede or invalidate older information *by convention* (e.g. a “tombstone” or “update” segment).
   * But the underlying older segments remain present and readable.
   * Logical state may change; physical history never does.

9. **Schema evolution without rewrite**

   * Payloads may include versioning or type tags.
   * New schemas must be designed so that old segments remain valid TaraSON documents.
   * Interpretation logic evolves; existing tapes are not rewritten to “upgrade” old segments.

10. **Reference transparency of segments**

* A segment’s identity (e.g. `segment_id`) is determined solely by its contents (payload + metadata) under a chosen scheme (hash, etc.).
* If two segments have the same identity, they have the same contents.
* This allows content-addressing, deduplication, and reliable linking, but the kernel does not prescribe a specific hashing scheme.

---

## 4. What is outside the Tape kernel

These are explicitly *not* part of the kernel, even if Simuleos uses them:

* Query languages and executors (SQL, graph queries,…).
* Indexes (by time, by scope, by parameter, full-text, …).
* External storage systems (SQL databases, search engines, object stores, git, etc.).
* Any caching, materialized views, or denormalized representations.
* Any UI-level or workflow-level concepts.

All of those are *consumers and producers* of segments on tapes.
They may maintain their own state, but that state is considered *derived* and *rebuildable* from the Tape kernel.
