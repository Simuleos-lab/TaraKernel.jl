# Minimal reinplementation

- The goal is to use existing and established technologies to achieve the objectives of The Tara Project.
- Only the minimal missing components should be implemented.
- #NoReimplementation


# The Tara Kernel

- The kernel has no hidden state outside the Tape.
- The Tape is the single canonical substrate.
    - It plays the role of the physical “source of truth”.
    - All higher-level structures (graphs, tables, indexes, caches, virtual DBs) are projections derived from Tape segments.
- Everything meaningful must be encoded in TaraSON segments.
- All other layers interpret, index, or transform Tape content without extending the kernel’s semantics.


# The Tara hardware-ish analogy

- The only physically existing structure is an append-only sequence of immutable segments.
- Any “state” is the result of replaying, summarizing, or interpreting this log.
- Extensibility happens by introducing new segment kinds or new ways to interpret segment sequences, never by altering the Tape model.


# A single Tape kernel

- Only one canonical Tape model exists.
- Implementation differences (compression, directory layout, IO strategies, caching) do not affect kernel semantics.
- Extensions belong to interpretation layers, not to the storage shape.  
- #NoReimplementation.
    - We are not inventing multiple storage models.
    - The substrate is a single, simple, rigorous Tape construct (`#TaraTape`).
    - All higher-level power comes from how segments are interpreted and combined.


# Canonical Hashing Base (the “expanded form”)

- Every segment payload must be convertible into a `CanonicalForm`.
- `CanonicalForm` is the reference representation for computing the `canonical.content.hash`.
- This form includes:
    - deterministic key ordering,
    - deterministic scalar and string serialization,
    - a strict TaraSON-compatible flattening.
- Two tapes are equivalent if, after canonical expansion, they produce the same ordered list of canonical TaraSON segment representations.
- The kernel does not need to store expanded payloads; it only defines what canonical expansion means.


# Multi hash system

- Segment naming conventions may expose different identifiers for different use cases.

- `canonical.content.hash`
    - Computed from the canonical representation.
    - The universal, stable identifier for deduplication, validation, linking, and long-term reference.

- `disk.content.hash`
    - Computed directly from the raw bytes of the on-disk representation.
    - Useful for fast local deduplication.
    - Not stable across different encodings of equivalent content.

- `random.hash`
    - A content-independent identifier.
    - Useful for runtime handles, temporary references, or non-canonical addressing.

